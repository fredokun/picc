\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage[hidelinks=true, pdfborder = {0 0 .1}, linkbordercolor= {gray}]{hyperref}

\definecolor{compilecolor}{gray}{0.45}
\definecolor{synchrocolor}{rgb}{0.1, 0.2, 0.8}
\title{PiThread Compiler Specifications}
\date{\today}
\author{AurÃ©lien Deharbe and Fr\'ed\'eric Peschanski\\ UPMC -- LIP6 -- APR}

\newenvironment{program}{
  \begin{sffamily}
  \begin{scriptsize}
  \begin{tabbing}}
 {\end{tabbing}
  \end{scriptsize}
  \end{sffamily}}

\newcommand{\kw}[1]{\textsf{\textbf{#1}}}
\newcommand{\pindent}{\hspace{2em}\=}
\newcommand{\compiletime}[1]{\textcolor{compilecolor}{#1}}
\newcommand{\synchro}[1]{\textcolor{synchrocolor}{#1}}
\newcommand{\code}[1]{\textsf{#1}}

\newcommand{\algotitle}[1]{\noindent\\ \noindent#1\par\nobreak\vspace{3pt}\hrule\vspace{6pt}}
\newcommand{\algosection}[1]{
  \phantomsection
%  \addcontentsline{toc}{subsubsection}{#1}
  \algotitle{#1}
}
\newcommand{\myref}[1]{
  \hyperref[#1]{#1}
}

\begin{document}

\renewcommand{\contentsname}{Table of contents}
\maketitle
$ $\newline
$ $\newline
\begin{center}
\includegraphics[scale=0.45]{pithreads.png}
\end{center}
\newpage
\tableofcontents
\newpage

%%%%%%%%%%%%%%% Section COMMENTS %%%%%%%%%%%%%%%%%%
\section{Comments}

\noindent
\begin{itemize}
\item \footnotesize Colors :
  \begin{itemize}
  \item \compiletime{Instructions in grey are compilation time.}
  \item Instructions in black are runtime.
  \item \synchro{Instructions in blue are related to thread synchronization.}
  \end{itemize}
\item \footnotesize Runtime environment notation :
  \begin{itemize}
  \item $pt.env[i]$ access to $i^{th}$ element of env when $i$ is an integer.
  \item $pt.env[v]$ is a shortcut to access to $i^{th}$ element of env with $i$ being the index of var $v$ (index solved in the compilation environment).
  \end{itemize}
\item \footnotesize The $eval$ function defined in the guarded choice, for lazy expression evaluation of output, is not a closure.
\end{itemize}


%%%%%%%%%%%%%%% Section DATA STRUCTURES %%%%%%%%%%%
\section{Basic data structures and operation signatures}


\label{PiThread}
\algosection{PiThread}
\begin{program}
  \kw{record} PiThread \{ \\
  \pindent status : \{STATUS\_RUN, STATUS\_CALL, STATUS\_WAIT, STATUS\_ENDED\}, \\
  \> enabled : Array[\kw{boolean}], \\
  \> knows : \myref{KnowSet}[\myref{Channel}], \\
  \> env : Array[Object], \\
  \> commit : Commit \\
  \> commits : Set[Commit] \\
  \> proc : \kw{function}, \\
  \> pc : \kw{label}, \\
  \> val : Value, \\
  \> clock : \myref{Clock} \\
  \> fuel : \kw{int} \\
  \> \synchro{lock : Mutex} \\
  \} \\ \\
  \myref{CanAwake} : \myref{PiThread} x \myref{Commit} $\rightarrow$ \kw{boolean} \\
  \myref{Awake} : \myref{SchedPool} x \myref{PiThread} x Commit $\rightarrow$ \kw{void}
\end{program}

\label{Channel}
\algosection{Channel}
\begin{program}
  \kw{record} Channel \{ \\
  \pindent incommits : \myref{CommitList}[\myref{InCommit}] \\
  \>outcommits : \myref{CommitList}[\myref{OutCommit}] \\
  \>globalrc : \kw{int} \\
  \>\synchro{lock : AtomicBoolean} \\
  \} \\ \\
  \myref{RegisterOutputCommitment} : \myref{PiThread} x \myref{Channel} \kw{var} x Expr x \kw{dynLabel} $\rightarrow$ \kw{void} \\
  \myref{RegisterInputCommitment} : \myref{PiThread} x \myref{Channel} \kw{var} x Env \kw{var} x \kw{dynLabel} $\rightarrow$ \kw{void} \\
  \myref{FetchOutputCommitment} : \myref{PiThread} x \myref{Channel} \kw{var} $\rightarrow$ \myref{OutCommit} \\
  \myref{FetchInputCommitment} : \myref{PiThread} x \myref{Channel} \kw{var} $\rightarrow$ \myref{InCommit} \\
  \myref{ChannelIncrRefCount} : \myref{Channel} $\rightarrow$ \kw{void} \\
  \myref{ChannelDecRefCount} : \myref{Channel} $\rightarrow$ \kw{void}
\end{program}

\label{InCommit}
\algosection{Input Commitment}
\begin{program}
  \kw{record} InCommit \{ \\
  \pindent thread : \myref{PiThread}, \\
  \>refvar : \kw{int}, \\
  \>clock : \myref{Clock} \\
  \>clockval : \kw{int} \\
  \>cont\_pc : \kw{int} \\
  \>channel : \myref{Channel} \\
  \} \\ \\
  \myref{IsValidInCommit} : \myref{InCommit} $\rightarrow$ \kw{boolean}
\end{program}

\label{OutCommit}
\algosection{Output Commitment}
\begin{program}
  \kw{record} OutCommit \{ \\
  \pindent thread : \myref{PiThread}, \\
  \>evalfunc : \kw{function}(\myref{PiThread}), \\
  \>clock : \myref{Clock} \\
  \>clockval : \kw{int} \\
  \>cont\_pc : \kw{int} \\
  \>channel : \myref{Channel} \\
  \} \\ \\
  \myref{IsValidOutCommit} : \myref{OutCommit} $\rightarrow$ \kw{boolean}
\end{program}

\label{Clock}
\algosection{Clock}
\begin{program}
  \kw{record} Clock \{ \\
  \pindent val : AtomicInt \\
  \}
\end{program}

\algosection{CommitList}
\begin{program}
  /* CommitListAdd add the selected element at the end of the CommitList */ \\
  \kw{abstract} CommitListAdd : CommitList x Commit $\rightarrow$ \kw{void} \\ \\
  /* CommitListFetch removes the first element from the CommitList and returns it */ \\
  \kw{abstract} CommitListFetch : CommitList $\rightarrow$ Commit
\end{program}

\algosection{ConcurrentReadyQueue}
\begin{program}
  /* ReadyQueuePush push a PiThread on the top of a ReadyQueue */ \\
  \myref{ReadyQueuePush} : ReadyQueue x \myref{PiThread} $\rightarrow$ \kw{void} \\ \\
  /* ReadyQueueAdd add a PiThread at the end of a ReadyQueue */ \\
  \myref{ReadyQueueAdd} : ReadyQueue x \myref{PiThread} $\rightarrow$ \kw{void} \\ \\
  /* ReadyQueuePop pop a PiThread from the top of a ReadyQueue */ \\
  \myref{ReadyQueuePop} : ReadyQueue $\rightarrow$ \myref{PiThread} \\ \\
  /* ReadyQueueSize returns the number of elements in a ReadyQueue */ \\
  \myref{ReadyQueueSize} : ReadyQueue $\leftarrow$ \kw{int}
\end{program}

\algosection{ConcurrentWaitQueue}
\begin{program}
  /* WaitQueuePush pushes a PiThread at the top of a WaitQueue */ \\
  \myref{WaitQueuePush} : WaitQueue x \myref{PiThread} $\rightarrow$ \kw{void} \\ \\
  /* WaitQueueFetch pop a selected PiThread from a WaitQueue */ \\
  \myref{WaitQueueFetch} : WaitQueue x \myref{PiThread} $\rightarrow$ \myref{PiThread} \\ \\
  /* WaitQueuePushOld pushes a PiThread at the top of the old PiThreads in a WaitQueue */ \\
  \myref{WaitQueuePushOld} : WaitQueue x \myref{PiThread} $\rightarrow$ \kw{void} \\ \\
  /* WaitQueuePopOld pop the older PiThread from a WaitQueue */ \\
  \myref{WaitQueuePopOld} : WaitQueue $\rightarrow$ \myref{PiThread} \\ \\
  /* WaitQueueSize returns the number of elements in a WaitQueue */ \\
  \myref{WaitQueueSize} : WaitQueue $\rightarrow$ \kw{int} \\ \\
  /* WaitQueueMaxActive returns the number of active elements in a WaitQueue */ \\
  \myref{WaitQueueMaxActive} : WaitQueue $\rightarrow$ \kw{int} \\ \\
  /* WaitQueueMaxActiveReset reset the counter of active elements in a WaitQueue (i.e. active elements are now old elements) */ \\
  \myref{WaitQueueMaxActiveReset} : WaitQueue $\rightarrow$ \kw{int}
\end{program}

\algosection{KnowSet}
\begin{program}
  \kw{type} KnowsState : \{UNKNOWN, KNOWN, FORGET\} \\ \\
  /* KnowSetKnows returns a subset of all KNOWN-state in a KnowSet */ \\
  \kw{abstract} KnowSetKnows : KnowSet $\rightarrow$ KnowSet \\ \\
  /* KnowSetForget returns a subset of all FORGET-state in a KnowSet */ \\
  \kw{abstract} KnowSetForget : KnowSet $\rightarrow$ KnowSet \\ \\
  /* KnowSetForgetToUnknown switches an element of a KnowSet from the FORGET-State to the UNKNOWN-state */ \\
  \kw{abstract} KnowSetForgetToUnknown : KnowSet x \myref{Channel} \kw{var} $\rightarrow$ \kw{void} \\ \\
  /* KnowSetForgetAll switches all KNOWN-state elements of a KnowSet to FORGET-state */ \\
  \kw{abstract} KnowSetForgetAll : KnowSet $\rightarrow$ \kw{void} \\ \\
  /* KnowsRegister looks for a channel in a KnowSet : \\
  \pindent * if the channel is in the KnowSet in KNOWN-state, it returns false \\
  \> * if the channel is in the KnowSet in FORGET-state, it switches it to KNOWN then returns false \\
  \> * else it adds the channel in the KnowSet (KNOWS-state) then returns true */ \\
  \kw{abstract} KnowsRegister : KnowSet x \myref{Channel} \kw{var} $\rightarrow$ \kw{boolean}
\end{program}


%%%%%%%%%%%%%%% Section SYNTAX %%%%%%%%%%%%%%%

\section{Syntax}


\begin{tabular}{llll}
Module & ::= & \kw{module} $moduleId$ Definition$+$ & (module definition) \\
\\
Definition & ::= &  \kw{def} $D(x_1:T_1, ..., x_n:T_n) = $ Process & (process definition) \\
\\
Process & ::= & \kw{end} & (end process) \\
        &    &  $|$ $D(e_1$:T$_1, ..., e_n$:T$_n)$ & (tail-call process) \\
        &    &  $|$ PrefixProcess & (prefixed process) \\
        &    &  $|$ ChoiceProcess & (choice process) \\
\\
PrefixProcess & ::= & $chan$\code{!}$expr$ \code{,} Process & (output prefix) \\
              &     & $|$ $chan$\code{?}$(x:T)$ \code{,} Process & (input prefix) \\
              &     & $|$ \kw{new}$(chan:T)$ \code{,} Process & (new channel prefix) \\
              &     & $|$ \kw{spawn}\code{\{}$(D(e_1$:T$_1, ..., e_n$:T$_n))$\code{\}} \code{,} Process & (spawn process prefix) \\
              &     & $|$ \kw{let}$(x:T=e)$\code{,} Process & (let prefix) \\
              &     & $|$ \code{\#}$prim(e_1$:T$_1, ..., e_n$:T$_n)$\code{,} Process & (primitive call prefix) \\
\\
ChoiceProcess & ::= & $\sum_{i=0}^{n-1}$\code{[}Expression$_i$\code{]} ProcessBranch$_i$ \\
\\
ProcessBranch & ::= & \kw{tau} \code{,} Process & (silent branch) \\
              &     & $|$ $chan$\code{!}$val$ \code{,} Process & (output branch) \\
              &     & $|$ $chan$\code{?}$(x:T)$ \code{,} Process & (input branch) \\
\\
\\
Expression & ::= & Constant \\
           &     & $|$ $v$  & (free variable) \\
           &     & $|$ \kw{op} Expression & (unary operator) \\
           &     & $|$ Expression$_l$ \kw{op} Expression$_r$  & (binary operator) \\
           &     & $|$ \code{\#}$vprim(e_1$:T$_1, ..., e_n$:T$_n)$ & (value primitive) \\
\end{tabular}


%%%%%%%%%%%%%%% Section COMPILATION %%%%%%%%%%%%%%%
\section{Compilation outlines and runtime functions}

\subsection{Compilation of expressions}

\label{CompileExpr}
\algosection{Compilation outline for constants}
\begin{program}
  \compiletime{CompileExpr(\kw{true}) $\rightarrow$} \\
  $pt.val \leftarrow$ \kw{true}
\end{program}

\begin{program}
  \compiletime{CompileExpr(\kw{false}) $\rightarrow$} \\
  $pt.val \leftarrow$ \kw{false}
\end{program}

\algosection{Compilation outline for var}
\begin{program}
  \compiletime{CompileExpr($v$ : \kw{var}) $\rightarrow$} \\
  $pt.val \leftarrow pt.env[v]$
\end{program}

\algosection{Compilation outline for unary operators}
\begin{program}
  \compiletime{CompileExpr(\kw{op} $b$) $\rightarrow$} \\
  \compiletime{CompileExpr($b$)} \\
  $pt.val \leftarrow$ \kw{op} $pt.val$
\end{program}

\algosection{Compilation outline for binary operators}
\begin{program}
  \compiletime{CompileExpr($a$ \kw{and} $b$) $\rightarrow$} \\
  \compiletime{CompileExpr($a$)} \\
  \kw{if} $pt.val$ \kw{then} \\
  \pindent\compiletime{CompileExpr($b$)} \\
  \kw{endif}
\end{program}

\begin{program}
  \compiletime{CompileExpr($a$ \kw{or} $b$) $\rightarrow$} \\
  \compiletime{CompileExpr($a$)} \\
  \kw{if} \kw{not} $pt.val$ \kw{then} \\
  \pindent\compiletime{CompileExpr($b$)} \\
  \kw{endif}
\end{program}

\begin{program}
  \compiletime{CompileExpr($a$ \kw{op} $b$) $\rightarrow$} \\
  \kw{begin} \\
  \pindent\compiletime{CompileExpr($a$)} \\
  \>\kw{var} $temp$ : \kw{Value} \\
  \>$temp \leftarrow pt.val$ \\
  \>\compiletime{CompileExpr($b$)} \\
  \>$pt.val \leftarrow pt.val$ \kw{op} $temp$ \\
  \kw{end}
\end{program}

\algosection{Compilation outline for value primitives}
\begin{program}
\compiletime{CompileExpr(\code{\#}$vprim(e_1$:T$_1, ..., e_n$:T$_n)$) $\rightarrow$} \\
  \kw{begin} \\
  \pindent \compiletime{\kw{cfor} $i$ : \kw{int} \kw{from} $1$ \kw{to} $n$ \kw{do}} \\
  \> \pindent \kw{var} $v_i$ : T$_i$ \\
  \> \> \compiletime{CompileExpr($e_i$)} \\
  \> \> $v_i \leftarrow pt.val$ \\
  \> \compiletime{\kw{cendfor}} \\
  \> $pt.val \leftarrow$ \code{\#}$vprim$($v_1$, $\ldots$, $v_n$) \\
  \kw{end}
\end{program}


\subsection{Compilation of Processes}

\algosection{Compilation outline for definition}
\begin{program}
  \compiletime{Compile(\kw{def} $D(x_1, ..., x_n) = P$) $\rightarrow$} \\ \\
  \compiletime{\kw{cvar} $D\_entry$ : \kw{DynLabel}} \\
  \compiletime{$D\_entry \leftarrow$ GenerateLabel()} \\
  \kw{function} $D$(\myref{SchedPool} $scheduler$, \myref{PiThread} $pt$) \{ \\
  \pindent\kw{switch} $pt.pc$ \{ \\
  \>\kw{case} $@D\_entry:$ \\
  \>\pindent\compiletime{Compile($P$)} \\
  \>\} \\
  \}
\end{program}

\algosection{Compilation outline for termination}
\begin{program}
  \compiletime{Compile(\kw{end}) $\rightarrow$} \\ \\
  ProcessEnd($pt$, STATUS\_ENDED) \\
  \kw{return}
\end{program}

\label{ProcessEnd}
\algosection{Runtime: process end}

\begin{program}
  \kw{procedure} ProcessEnd($pt$ : \myref{PiThread}, $status$ : \myref{ProcessStatus})\\
\kw{begin} \\
\pindent  \kw{foreach} $chan$ : \myref{Channel} in \myref{KnowSetKnows}($pt.knows$) \\
\> \pindent\myref{ChannelDecRefCount}($chan$) \\
\>  \kw{endfor} \\
\>  \kw{foreach} $chan$ : \myref{Channel} in \myref{KnowSetForget}($pt.knows$) \\
\>  \pindent\myref{ChannelDecRefCount}($chan$) \\
\>  \kw{endfor} \\
\>  $pt.status \leftarrow status$ \\
\kw{end}
\end{program}


\algosection{Compilation outline for call}
\begin{program}
  \compiletime{Compile($D(v_1$:T$_1, ..., v_n$:T$_n)) \rightarrow$} \\ \\
  \kw{begin} \\
  \pindent\myref{KnowSetForgetAll}($pt.knows$) \\
  \>\\
  \>\compiletime{\kw{cfor} $i$ : \kw{int} \kw{from} $1$ \kw{to} $n$} \\
  \>\pindent var $v_i$ : $T_i$ \\
  \>\>\compiletime{\myref{CompileExpr}($v_{i}$)} \\
  \>\>$v_i \leftarrow pt.val$ \\
  \>\compiletime{\kw{cendfor}} \\
  \>\\
  \>\compiletime{\kw{cfor} $i$ : \kw{int} \kw{from} $1$ \kw{to} $n$} \\
  \>\pindent $pt.env[i-1] \leftarrow v_i$ \\
  \>\>\compiletime{\kw{cif} ischannel(T$_{i}$) \kw{then}} \\
  \>\>\pindent\myref{KnowsRegister}($pt.knows, v_i$) \\
  \>\>\compiletime{\kw{cendif}} \\
  \>\compiletime{\kw{cendfor}} \\
  \>\\
  \>$pt.proc \leftarrow D$ \\
  \>$pt.pc \leftarrow @D\_entry$ \\
  \>$pt.status \leftarrow$ STATUS\_CALL \\
  \>\kw{return} \\
  \kw{end}
\end{program}

\subsection{Compilation of prefixed processes}

\algosection{Compilation of prefixed process}
\begin{program}
  \compiletime{Compile($\alpha$,$P$)} $\rightarrow$ \\
\compiletime{CompilePrefix($\alpha$)} \\
\compiletime{Compile($P$)}\\
\end{program}

\algosection{Compilation outline for output prefix}
\begin{program}
  \compiletime{CompilePrefix($c!e$:T)} $\rightarrow$ \\ 
  \compiletime{cvar @prefix\_start : dynLabel} \\
  \compiletime{@prefix\_start $\leftarrow$ GenerateLabel()} \\
  \compiletime{cvar @prefix\_cont : dynLabel} \\
  \compiletime{@prefix\_cont $\leftarrow$ GenerateLabel()} \\
  \kw{case} @prefix\_start: \\
  \kw{begin} \\
   \pindent \kw{var} $ok$ : \kw{bool} \\
   \> $ok \leftarrow $ ProcessAcquireChannel($pt$, $pt.env[c]$) \\
  \> \kw{if} \kw{not} $ok$  \kw{then} \\
  \> \pindent $pt.pc \leftarrow $ @prefix\_start \\
  \>  \> ProcessYield($pt$) \\
  \>  \> \kw{return}\\
  \>  \kw{endif} \\
   \>\kw{var} $commit$ : \myref{InCommit} \\
  \> $commit \leftarrow$ TryOutputAction($pt$, $pt.env[c]$, $\& tryResult$)\\
  \>\kw{if} $tryResult$ = ENABLED \kw{then} \\
  \>\pindent \synchro{ReleaseChannel($pt.env[c]$)} \\
  \>\>\compiletime{\myref{CompileExpr}($e$)} \\
  \>\>$commit.thread.env[commit.refval] \leftarrow pt.val$ \\
  \>\>\myref{Awake}($scheduler$, $commit.thread$, $commit$) \\
  \>\>\kw{goto} @prefix\_cont \\
 \> \kw{elseif} $tryResult$ = DISABLED \kw{then} \\
 \> \> \synchro{ReleaseChannel($pt.env[c]$)} \\
 \> \> \myref{ProcessEnd}($pt$, STATUS\_BLOCKED) \\
 \> \> \kw{return} \\
 \> \kw{endif}\\
\\
  \>\kw{var} $eval$ : \kw{function}($pt$ : PiThread) : Value = \\
  \>\pindent\kw{begin} \\
  \>\>\pindent\compiletime{\myref{CompileExpr}($v$)} \\
  \>\>\>\kw{return} $pt.val$ \\
  \>\> \kw{end} \\
  \> \myref{RegisterOutputCommitment}($pt, pt.env[c], eval, @prefix\_cont$) \\
  \>\synchro{Acquire($pt.lock$)} \\
  \>\synchro{\myref{ReleaseChannel}($pt.env[c]$)} \\
  \>\synchro{\myref{ProcessWait}($pt$)} \\
  \>\kw{return} \\
  \kw{end} \\
 \kw{case} \@prefix\_cont:
\end{program}

\algosection{Runtime : try output action}
\begin{program}
  \kw{type} TryResult = \{ DISABLED, ENABLED, COMMIT \} \\
\\
  \kw{function} TryOutputAction(\=$pt$ : \myref{PiThread}, $outchan$ : \myref{Channel}, $tryResult$: \&TryStatus) : \myref{InCommit} \\
  \kw{begin} \\
  \pindent\kw{if} $outchan.globalrc = 1$ \kw{then} \\
  \>\pindent$tryResult \leftarrow$ DISABLED \\
  \>\>\kw{return} \kw{null} \\
  \>\kw{endif} \\
  \>\kw{var} $commit$ : \myref{InCommit} \\
  \>\kw{var} $ok$ : \{CANNOT\_ACQUIRE, VALID\_COMMITMENT, INVALID\_COMMITMENT\} \\
  \>\\
  \>\kw{do} \\
  \>\pindent$commit \leftarrow$ \myref{FetchInputCommitment}($outchan$) \\
  \>\>\kw{if} $commit =$ \kw{null} \kw{then} \\
  \>\>\pindent$tryresult \leftarrow$ COMMIT \\
  \>\>\>\kw{return} \kw{null} \\
  \>\>\kw{endif} \\

  \>\>\kw{do} \\
  \>\>\pindent$ok \leftarrow$ \myref{CanAwake}($commit.thread, commit$) \\
  \>\>\>\kw{if} $ok =$ CANNOT\_ACQUIRE \kw{then} \\
  \>\>\>\pindent\synchro{lowLevelYield()} \\
  \>\>\>\kw{endif} \\
  \>\>\kw{while} $ok =$ CANNOT\_ACQUIRE \\
  \>\>\\
  \>\>\kw{if} $ok =$ VALID\_COMMITMENT \kw{then} \\
  \>\>\> $tryResult \leftarrow$ ENABLED \\
  \>\>\> \kw{return} commit \\
  \>\>\kw{endif} \\
  \>\kw{while} $outchan.incommits \neq \{\}$ \\
  \> errorDeadCodeReached() \\
  \kw{end}
\end{program}

\algosection{Runtime : Process acquire channel}
\begin{program}
  \kw{function} ProcessAcquireChannel($pt$ : \myref{PiThread}, $outchan$ : \myref{Channel}) : \kw{bool} \\
\kw{begin} \\
  \pindent \kw{while} \kw{not} \synchro{TryAcquireChannel($outchan$)} \kw{do} \\
  \> \pindent $pt.fuel \leftarrow pt.fuel - 1$ \\
  \> \> \kw{if} $pt.fuel = 0$ \kw{then} \\
  \> \> \pindent \kw{return} \kw{false} \\
  \> \> \kw{endif} \\
  \> \> \synchro{low\_level\_yield()} \\
  \> \kw{endwhile} \\
  \> \kw{return} \kw{true} \\
\kw{end} 

\end{program}


\label{ProcessWait}
\algosection{Runtime: process wait}
\begin{program}
  \kw{procedure} ProcessWait($pt$ : \myref{PiThread})\\
\kw{begin} \\
\pindent  $pt.pc \leftarrow$ INVALID\_PC \\
\>  $pt.fuel \leftarrow$ FUEL\_INIT \\
\>  \kw{foreach} $chan$ : \myref{Channel} in \myref{KnowSetForget}($pt.knows$) \\
\>  \pindent\myref{ChannelDecRefCount}($chan$) \\
\>  \>\myref{KnowSetForgetToUnknown}($pt.knows, chan$) \\
\>  \kw{endfor} \\
\>  $pt.status \leftarrow$ STATUS\_WAIT \\
\>  \synchro{\myref{WaitQueuePush}($scheduler.wait$, $pt$)} \\
\>  \synchro{Release($pt.lock$)} \\
\kw{end}
\end{program}


\label{ProcessYield}
\algosection{Runtime: process yield}

\begin{program}
  \kw{procedure} ProcessYield($pt$ : \myref{PiThread})\\
\kw{begin} \\
\pindent  $pt.fuel \leftarrow$ FUEL\_INIT \\
\>  \kw{foreach} $chan$ : \myref{Channel} in \myref{KnowSetForget}($pt.knows$) \\
\>  \pindent\myref{ChannelDecRefCount}($chan$) \\
\>  \>\myref{KnowSetForgetToUnknown}($pt.knows, chan$) \\
\>  \kw{endfor} \\
\>  \synchro{\myref{ReadyQueueAdd}($scheduler.ready, pt$)} \\
\kw{end}
\end{program}

\algosection{Compilation outline for input prefix}
\begin{program}
  \compiletime{CompilePrefix($c?x$:T) $\rightarrow$} \\ \\
  \compiletime{cvar @prefix\_start : dynLabel} \\
  \compiletime{@prefix\_start $\leftarrow$ GenerateLabel()} \\
  \compiletime{cvar @prefix\_cont : dynLabel} \\
  \compiletime{@prefix\_cont $\leftarrow$ GenerateLabel()} \\
  \kw{case} @prefix\_start: \\
  \kw{begin} \\
   \pindent \kw{var} $ok$ : \kw{bool} \\
   \> $ok \leftarrow $ ProcessAcquireChannel($pt$, $pt.env[c]$) \\
  \> \kw{if} \kw{not} $ok$  \kw{then} \\
  \> \pindent $pt.pc \leftarrow $ @prefix\_start \\
  \>  \> ProcessYield($pt$) \\
  \>  \> \kw{return}\\
  \>  \kw{endif} \\
  \pindent\kw{var} $commit$ : \myref{OutCommit} \\
  \> $commit \leftarrow$ TryInputAction($pt$, $pt.env[c]$, $\& tryResult$) \\
  \>\kw{if} $tryResult =$ ENABLED \kw{then} \\
  \>\pindent \synchro{ReleaseChannel($pt.env[c]$)} \\
  \>\> $pt.env[x] \leftarrow$ commit.evalfunc($commit.thread$) \\
  \>\>\compiletime{\kw{cif} ischannel(T) \kw{then}} \\
  \>\>\pindent\kw{if} \myref{KnowsRegister}($pt.knows, pt.env[x]$) \kw{then} \\
  \>\>\>\pindent \myref{ChannelRef}($pt.env[x]$) \\
  \>\>\>\kw{endif} \\
  \>\>\compiletime{\kw{cendif}} \\
  \>\>\myref{Awake}($scheduler, commit.thread, commit$) \\
  \>\>\kw{goto} @prefix\_cont \\
  \>\kw{elseif} $tryResult =$ DISABLED \kw{then} \\
  \>\> \synchro{ReleaseChannel($pt.env[c]$)} \\
 \> \> \myref{ProcessEnd}($pt$, STATUS\_BLOCKED) \\
 \> \> \kw{return} \\
  \>\kw{endif} \\
\\
  \> \myref{RegisterInputCommitment}($pt, pt.env[c], x, @prefix\_cont$) \\
  \>\synchro{Acquire($pt.lock$)} \\
  \>\synchro{\myref{ReleaseChannel}($pt.env[c]$)} \\
  \>\synchro{\myref{ProcessWait}($pt$)} \\
  \>\kw{return} \\
  \kw{end} \\
 \kw{case} \@prefix\_cont:
\end{program}

\algosection{Runtime : try input action}
\begin{program}
  \kw{type} TryResult = \{ DISABLED, ENABLED, COMMIT \} \\
\\
  \kw{function} TryInputAction($pt$ : \myref{PiThread}, $inchan$ : \myref{Channel} , $tryResult$: \&TryResult) : \myref{OutCommit} \\
  \kw{begin} \\
  \pindent\kw{if} $inchan.globalrc = 1$ \kw{then} \\
  \>\pindent$tryResult \leftarrow$ DISABLED \\
  \>\>\kw{return} \kw{null} \\
  \>\kw{endif} \\
  \>\kw{var} $commit$ : \myref{OutCommit} \\
  \>\kw{var} $ok$ : \{CANNOT\_ACQUIRE, VALID\_COMMITMENT, INVALID\_COMMITMENT\} \\
  \>\\
  \>\kw{do} \\
  \>\pindent$commit \leftarrow$ \myref{FetchOutputCommitment}($inchan$) \\
  \>\>\kw{if} $commit =$ \kw{null} \kw{then} \\
  \>\>\pindent$tryresult \leftarrow$ COMMIT \\
  \>\>\>\kw{return} \kw{null} \\
  \>\>\kw{endif} \\

  \>\>\kw{do} \\
  \>\>\pindent$ok \leftarrow$ \myref{CanAwake}($commit.thread, commit$) \\
  \>\>\>\kw{if} $ok =$ CANNOT\_ACQUIRE \kw{then} \\
  \>\>\>\pindent\synchro{lowLevelYield()} \\
  \>\>\>\kw{endif} \\
  \>\>\kw{while} $ok =$ CANNOT\_ACQUIRE \\
  \>\>\\
  \>\>\kw{if} $ok =$ VALID\_COMMITMENT \kw{then} \\
  \>\>\> $tryResult \leftarrow$ ENABLED \\
  \>\>\> \kw{return} commit \\
  \>\>\kw{endif} \\
  \>\kw{while} $inchan.outcommits \neq \{\}$ \\
  \> errorDeadCodeReached() \\
  \kw{end}
\end{program}


\algosection{Compilation outline for channel creation}
\begin{program}
  \compiletime{CompilePrefix(\kw{new}($c$)) $\rightarrow$} \\ 
  $pt.env[c] \leftarrow $ GenerateChannel($pt$) \\
\end{program}

\label{GenerateChannel}
\algosection{Runtime : channel generation}
\begin{program}
  \kw{function} GenerateChannel($pt$ : \myref{PiThread}) \\
  \pindent\kw{var} $newchan$ : \myref{Channel} \\
  \>$newchan \leftarrow$ \kw{new} Channel \\
  \>$newchan.incommits \leftarrow$ \kw{new} CommitList[\myref{InCommit}] \\
  \>$newchan.outcommits \leftarrow$ \kw{new} CommitList[\myref{OutCommit}] \\
  \>$newchan.globalrc \leftarrow 1$ \\ 
  \>\myref{KnowSetSwitch}($pt.knows, newchan$, KNOWN) \\
  \> \kw{return} $newchan$ \\
  \kw{endfunction}
\end{program}

\algosection{Compilation outline for thread creation}
\begin{program}
  \compiletime{CompilePrefix(\kw{spawn}\{D($e_1$:T$_1, ..., e_n$:T$_n$)\}) $\rightarrow$} \\ 
  \kw{begin} \\
  \pindent\kw{var} $child$ : \myref{PiThread} \\
  \>$child \leftarrow$ \myref{GeneratePiThread}(\compiletime{COMPUTED\_ENV\_SIZE}) \\
  \>\\
  \>\compiletime{\kw{cfor} $i$ : \kw{int} \kw{from} $1$ \kw{to} $n$} \\
  \>\pindent \kw{var} $v_i$ : Value \\
  \>\pindent\compiletime{\myref{CompileExpr}($e_i$)} \\
  \>\>$v_i \leftarrow pt.val$ \\
  \>\>\compiletime{\kw{cif} ischannel(T$_i$) \kw{then}} \\
  \>\>\pindent \myref{KnowsRegister}($child.knows, v_i$) \\
  \>\>\compiletime{\kw{cendif}} \\
  \>\>$child.env[i-1] \leftarrow v_i$ \\
  \>\compiletime{\kw{cendfor}} \\
  \>\\
  \>$child.proc \leftarrow D$ \\
  \>$child.pc \leftarrow @D\_entry$ \\
  \>$child.status \leftarrow$ STATUS\_RUN \\
  \>\synchro{\myref{ReadyQueuePush}($scheduler.ready, child$)} \\
  \kw{end}
\end{program}

\label{GeneratePiThread}
\algosection{Runtime : thread generation}
\begin{program}
  \kw{function} GeneratePiThread($env\_size$ : \kw{int}) \\
  \pindent\kw{var} $newthread$ : \myref{PiThread} \\
  \> $newthread \leftarrow$ \kw{new} PiThread($env\_size$) \\
  \> $newthread.knows \leftarrow$ \kw{new} KnowSet[\myref{Channel}] \\
  \> $newthread.fuel \leftarrow$ FUEL\_INIT \\
  \> \kw{return} $newthread$ \\
  \kw{endfunction}
\end{program}

\algosection{Compilation outline for let binding}
\begin{program}
  \compiletime{CompilePrefix(\kw{let}($x$:T = $e$)) $\rightarrow$} \\ 
  \compiletime{CompileExpr($e$)} \\
  $pt.env[x] \leftarrow $ $pt.val$ \\
\end{program}


\section{Compilation of choice process}

\algosection{Compilation outline for guarded choice}
\begin{program}
  \compiletime{Compile($\sum_{i=0}^{n-1}[g_i]\alpha_i.P_i$) $\rightarrow$} \\
  \compiletime{cvar @choice\_start : dynLabel} \\
  \compiletime{@choice\_start $\leftarrow$ GenerateLabel()} \\
  \compiletime{\kw{cvar} $choice\_cont$ : Array[\kw{dynLabel}]} \\
  \kw{case} @choice\_start: \\
  \kw{begin} \\ 
  \pindent\kw{var} $tryresult$ : \{ENABLED, DISABLED, COMMIT, ABORT\} \\
  \>\kw{var} $nbdisabled$ : \kw{int} \\
  \>$nbdisabled \leftarrow 0$ \\
  \>\kw{var} $chans$ : Array[\myref{Channel}]($n$) \\
  \>\kw{var} $nbchans$ : \kw{int} \\
  \>$nbchans \leftarrow 0$ \\
  \>\compiletime{\kw{cfor} $i$ : \kw{int} \kw{from} $0$ \kw{to} $n-1$} \\
  \>\pindent\compiletime{$choice\_cont[i] \leftarrow$ GenerateLabel()} \\
  \>\>\compiletime{\myref{CompileExpr}($g_i$)} \\
  \>\>$pt.enabled[i] \leftarrow pt.val$ \\
  \>\>\kw{if} $pt.enabled[i]$ \kw{then} \\
  \>\>\pindent\compiletime{\myref{CompileTryAction}($\alpha_i$)}[$chans$, $nbchans$,$tryResult$] \\
  \>\>\>\kw{if} $tryresult =$ DISABLED \kw{then} \\
  \>\>\>\pindent$pt.enabled[i] \leftarrow$ \kw{false} \\
  \>\>\>\>$nbdisabled \leftarrow nbdisabled + 1$ \\
  \>\>\>\kw{elseif} $tryresult =$ ABORT \kw{then} \\
  \>\>\>\>\synchro{\myref{ReleaseAllChannels}($chans$, $nbchans$)} \\
  \>\>\>\> $pt.pc \leftarrow$ @choice\_start \\
  \>\>\>\> ProcessYield($pt$) \\
  \>\>\>\> \kw{return} \\
  \>\>\>\kw{elseif} $tryresult =$ ENABLED \kw{then} \\
  \>\>\>\pindent\synchro{\myref{ReleaseAllChannels}($chans$, $nbchans$)} \\
  \>\>\>\pindent$pt.fuel \leftarrow pt.fuel - 1$ \\
  \>\>\>\>\kw{if} $pt.fuel = 0$ \kw{then} \\
  \>\>\>\>\pindent $pt.pc \leftarrow choice\_cont[i]$ \\
  \>\>\>\>\>\myref{ProcessYield}($pt$) \\
  \>\>\>\>\>\kw{return} \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\>\kw{goto} $@choice\_cont[i]$ \\
  \>\>\>\kw{endif} \\
    \>\>\kw{else} \\
  \>\>\pindent$nbdisabled \leftarrow nbdisabled + 1$ \\
  \>\>\kw{endif} \\
  \>\compiletime{\kw{cendfor}} \\
  \>\kw{if} $nbdisabled = n$ \kw{then} \\
  \>\pindent\synchro{\myref{ReleaseAllChannels}($chans$, $nbchans$)} \\
  \>\>\compiletime{Compile(\kw{end}, STATUS\_BLOCKED)} \\
  \>\kw{endif} \\
  \>\compiletime{\kw{cfor} $i$ : \kw{int} \kw{from} $0$ \kw{to} $n-1$} \\
  \>\pindent\kw{if} $pt.enabled[i]$ \kw{then} \\
  \>\>\pindent\compiletime{\kw{cif} $\alpha_i$ is $c!v$ \kw{then}} \\
  \>\>\>\pindent\kw{var} $eval$ : \kw{function}($pt$ : PiThread) : Value \{ \\
  \>\>\>\>\pindent\kw{begin} \\
  \>\>\>\>\>\pindent\compiletime{\myref{CompileExpr}($v$)} \\
  \>\>\>\>\>\>\kw{return} $pt.val$ \\
  \>\>\>\>\>\kw{end} \\
  \>\>\>\>\} \\
  \>\>\>\>\myref{RegisterOutputCommitment}($pt, pt.env[c], eval, choice\_cont[i]$) \\
  \>\>\>\compiletime{\kw{elseif} $\alpha_i$ is $c?x$ \kw{then}} \\
  \>\>\>\pindent\myref{RegisterInputCommitment}($pt, pt.env[c], x, choice\_cont[i]$) \\
  \>\>\>\compiletime{\kw{cendif}} \\
  \>\>\kw{endif} \\
  \>\compiletime{\kw{cendfor}} \\
  \>\synchro{Acquire($pt.lock$)} \\
  \>\synchro{\myref{ReleaseAllChannels}($chans$, $nbchans$)} \\
  \>\synchro{\myref{ProcessWait}($pt$:\myref{PiThread})} \\
  \>\kw{return} \\
  \>\compiletime{\kw{cfor} $i$ : \kw{int} \kw{from} $0$ \kw{to} $n-1$} \\
  \>\pindent \kw{case} $@choice\_cont[i]:$ \\
  \>\>\compiletime{Compile($P_i$)} \\
  \>\compiletime{\kw{cendfor}} \\
  \kw{end}
\end{program}

\label{CompileTryAction}
\algosection{Compilation outline for tau prefix try}
\begin{program}
  \compiletime{CompileTryAction(\kw{tau})}[\ldots $tryresult$:\{ENABLED, DISABLED, COMMIT\}] $\rightarrow$ \\ \\
  $tryresult \leftarrow$ ENABLED \\
\end{program}

\algosection{Compilation outline for output prefix try}
\begin{program}
  \compiletime{CompileTryAction($c!v$:T)}[$chans$ : Array[\myref{Channel}], $nbchans$ : \kw{int}, $tryresult$:\{ENABLED, DISABLED, COMMIT\}] $\rightarrow$ \\ \\
  \kw{begin} \\
  \pindent\kw{var} $commit$ : \myref{InCommit} \\
  \> $commit \leftarrow$ TryOutputAction($pt$, $c$, $chans$, $\&nbchans$, $\& tryResult$)\\
  \>\kw{if} $tryResult$ = ENABLED \kw{then} \\
  \>\pindent\compiletime{\myref{CompileExpr}($v$)} \\
  \>\>$commit.thread.env[commit.refval] \leftarrow pt.val$ \\
  \>\>\myref{Awake}($scheduler$, $commit.thread$, $commit$) \\
  \> \kw{endif}\\
  \kw{end}
\end{program}

\algosection{Runtime : try output action}
\begin{program}
  \kw{type} TryResult = \{ DISABLED, ENABLED, COMMIT \} \\
\\
  \kw{function} TryOutputAction(\=$pt$ : \myref{PiThread}, $chanRef$ : int, $chans$: Array[\myref{Channel}], $nbchans$ : \&\kw{int},\\
\> $tryResult$: \&TryStatus) : \myref{InCommit} \\
  \pindent \kw{var} $outchan$ : \myref{Channel} \\
  \> $outchan \leftarrow$ $pt$.$env$[$chanRef$] \\
  \pindent \kw{if} ChanArrayAdd($outchan$, $chans$, $\&nbchans$) \kw{then} \\
  \>\pindent\synchro{Acquire($outchan.lock$)} \\
  \>\kw{endif} \\
  \>\kw{if} $outchan.globalrc = 1$ \kw{then} \\
  \>\pindent$tryResult \leftarrow$ DISABLED \\
  \>\>\kw{return} \kw{null} \\
  \>\kw{endif} \\
  \>\kw{var} $commit$ : \myref{InCommit} \\
  \>\kw{var} $ok$ : \{CANNOT\_ACQUIRE, VALID\_COMMITMENT, INVALID\_COMMITMENT\} \\
  \>\\
  \>\kw{do} \\
  \>\pindent$commit \leftarrow$ \myref{FetchInputCommitment}($outchan$) \\
  \>\>\kw{if} $commit =$ \kw{null} \kw{then} \\
  \>\>\pindent$tryresult \leftarrow$ COMMIT \\
  \>\>\>\kw{return} \kw{null} \\
  \>\>\kw{endif} \\

  \>\>\kw{do} \\
  \>\>\pindent$ok \leftarrow$ \myref{CanAwake}($commit.thread, commit$) \\
  \>\>\>\kw{if} $ok =$ CANNOT\_ACQUIRE \kw{then} \\
  \>\>\>\pindent\synchro{lowLevelYield()} \\
  \>\>\>\kw{endif} \\
  \>\>\kw{while} $ok =$ CANNOT\_ACQUIRE \\
  \>\>\\
  \>\>\kw{if} $ok =$ VALID\_COMMITMENT \kw{then} \\
  \>\>\> $tryResult \leftarrow$ ENABLED \\
  \>\>\> \kw{return} commit \\
  \>\>\kw{endif} \\
  \>\kw{while} $outchan.incommits \neq \{\}$ \\
  errorDeadCodeReached() \\
  \kw{endfunction}
\end{program}

\algosection{Runtime : add channel in (statically allocated) array set}
\begin{program}
  \kw{function} ChanArrayAdd($newchan$ : \myref{Channel}, $chans$: Array[\myref{Channel}], $nbchans$ : \&\kw{int}) : \kw{bool} \\
  \pindent \kw{var} $i$ : \kw{int} \\
  \> $i \leftarrow$ 0 \\
  \> \kw{while} $i$ $<$ $nbchans$ \kw{do}\\
  \> \pindent \kw{if} $chans$[$i$] = $newchan$ \kw{then} \\
  \> \> \pindent \kw{return} false \\
  \> \> \kw{endif} \\
  \> \> $i \leftarrow$ $i$ + 1 \\
  \> \kw{endwhile} \\
  \> $chans$[$nbchans$] = $newchan$ \\
  \> $nbchans \leftarrow$ $nbchans$ + 1 \\
  \> \kw{return} true
  \kw{endfunction}
\end{program}

\algosection{Compilation outline for input prefix try}
\begin{program}
  \compiletime{CompileTryAction($c?x$:T, $chans$:Set[\myref{Channel}]) $\rightarrow$} \\ \\
  \kw{begin} \\
  \pindent\kw{var} $commit$ : \myref{OutCommit} \\
  \> $commit \leftarrow$ TryInputAction($pt$, $c$, $chans$, $\& tryResult$) \\
  \>\kw{if} $tryResult =$ ENABLED \kw{then} \\
  \>\pindent $pt.env[x] \leftarrow$ commit.evalfunc($commit.thread$) \\
  \>\>\compiletime{\kw{cif} ischannel(T) \kw{then}} \\
  \>\>\pindent\kw{if} \myref{KnowsRegister}($pt.knows, pt.env[x]$) \kw{then} \\
  \>\>\>\pindent \myref{ChannelIncrRefCount}($pt.env[x]$) \\
  \>\>\>\kw{endif} \\
  \>\>\compiletime{\kw{cendif}} \\
  \>\>\myref{Awake}($scheduler, commit.thread, commit$) \\
  \>\kw{endif} \\
  \kw{end}
\end{program}

\algosection{Runtime : try input action}
\begin{program}
  \kw{type} TryResult = \{ DISABLED, ENABLED, COMMIT \} \\
\\
  \kw{function} TryInputAction($pt$ : \myref{PiThread}, $chanRef$ : int, $chans$: Set[\myref{Channel}], $tryResult$: \&TryResyult) : \myref{OutCommit} \\
  \pindent \kw{var} $inchan$ : \myref{Channel} \\
  \> $inchan \leftarrow$ $pt$.$env$[$chanRef$] \\
  \> \kw{if} ChanArrayAdd($inchan$, $chans$, $\&nbchans$) \kw{then} \\
  \>\pindent\synchro{Acquire($inchan.lock$)} \\
  \>\kw{endif} \\
  \>\kw{if} $inchan.globalrc = 1$ \kw{then} \\
  \>\pindent$tryResult \leftarrow$ DISABLED \\
  \>\>\kw{return} \kw{null} \\
  \>\kw{endif} \\
  \>\kw{var} $commit$ : \myref{OutCommit} \\
  \>\kw{var} $ok$ : \{CANNOT\_ACQUIRE, VALID\_COMMITMENT, INVALID\_COMMITMENT\} \\
  \>\\
  \>\kw{do} \\
  \>\pindent$commit \leftarrow$ \myref{FetchOutputCommitment}($inchan$) \\
  \>\>\kw{if} $commit =$ \kw{null} \kw{then} \\
  \>\>\pindent$tryresult \leftarrow$ COMMIT \\
  \>\>\>\kw{return} \kw{null} \\
  \>\>\kw{endif} \\

  \>\>\kw{do} \\
  \>\>\pindent$ok \leftarrow$ \myref{CanAwake}($commit.thread, commit$) \\
  \>\>\>\kw{if} $ok =$ CANNOT\_ACQUIRE \kw{then} \\
  \>\>\>\pindent\synchro{lowLevelYield()} \\
  \>\>\>\kw{endif} \\
  \>\>\kw{while} $ok =$ CANNOT\_ACQUIRE \\
  \>\>\\
  \>\>\kw{if} $ok =$ VALID\_COMMITMENT \kw{then} \\
  \>\>\> $tryResult \leftarrow$ ENABLED \\
  \>\>\> \kw{return} commit \\
  \>\>\kw{endif} \\
  \>\kw{while} $inchan.outcommits \neq \{\}$ \\
  errorDeadCodeReached() \\
  \kw{endfunction}
\end{program}


\algosection{Runtime : atomic boolean acquisition}
\begin{program}
  \kw{function} Acquire($c$ : AtomicBoolean) \\
  \pindent\kw{while} CompareAndSwap($c$, \kw{false}, \kw{true}) $\neq$ \kw{false} \\
  \>\pindent// could not acquire \\
  \>\>\synchro{low\_level\_yield()} \\
  \>\kw{endwhile} \\
  \kw{endfunction}
\end{program}

\algosection{Runtime : atomic integer release}
\begin{program}
  \kw{function} Release($c$ : AtomicBoolean) \\
  \pindent\kw{if} CompareAndSwap($c$, \kw{true} \kw{false}) $\neq$ \kw{true} \kw{then} \\
  \>\pindent Crash(KERNEL\_ERROR) \\
  \>\kw{endif} \\
  \kw{endfunction}
\end{program}

\label{FetchInputCommitment}
\algosection{Runtime : input commitment search}
\begin{program}
  \kw{function} FetchInputCommitment($c$ : \myref{Channel}) \\
  \pindent\kw{var} $current$ : \myref{InCommit} \\
  \>$current \leftarrow$ \myref{CommitListFetch}($c.incommits$) \\
  \>\kw{while} $current \neq$ \kw{null} \kw{do} \\
  \>\pindent\kw{if} \myref{IsValidInCommit}($current$) \kw{then} \\
  \>\>\pindent\kw{return} $current$ \\
  \>\>\kw{endif} \\
  \>\>$current \leftarrow$ \myref{CommitListFetch}($c.incommits$) \\
  \>\kw{endwhile} \\
  \>\kw{return} \kw{null} \\
  \kw{endfunction}
\end{program}

\label{FetchOutputCommitment}
\algosection{Runtime : output commitment search}
\begin{program}
  \kw{function} FetchOutputCommitment($c$ : \myref{Channel}) \\
  \pindent\kw{var} $current$ : \myref{OutCommit} \\
  \>$current \leftarrow$ \myref{CommitListFetch}($c.outcommits$) \\
  \>\kw{while} $current \neq$ \kw{null} \kw{do} \\
  \>\pindent\kw{if} \myref{IsValidOutCommit}($current$) \kw{then} \\
  \>\>\pindent\kw{return} $current$ \\
  \>\>\kw{endif} \\
  \>\>$current \leftarrow$ \myref{CommitListFetch}($c.outcommits$) \\
  \>\kw{endwhile} \\
  \>\kw{return} \kw{null} \\
  \kw{endfunction}
\end{program}


\label{RegisterInputCommitment}
\algosection{Runtime : input commitment register}
\begin{program}
  \kw{function} RegisterInputCommitment($pt$: \myref{PiThread}, $c$ : \myref{Channel}, $x$ : \kw{int}, $cont\_pc$ : \kw{int}) \\
  \pindent\kw{var} $newcommit$ : \myref{InCommit} \\
  \>$newcommit \leftarrow$ \kw{new} InCommit \\
  \>$newcommit.thread \leftarrow pt$ \\
  \>$newcommit.cont\_pc \leftarrow cont\_pc$ \\
  \>$newcommit.refvar \leftarrow x$\\
  \>$newcommit.clock \leftarrow pt.clock$ \\
  \>$newcommit.clockval \leftarrow pt.clock.val$ \\
  \>$newcommit.channel \leftarrow c$ \\
  \>\myref{CommitListAdd}($pt.env[c].incommits$, $newcommit$) \\
  \kw{endfunction}
\end{program}

\label{RegisterOutputCommitment}
\algosection{Runtime : output commitment register}
\begin{program}
  \kw{function} RegisterOutputCommitment($pt$: \myref{PiThread}, $c$ : \myref{Channel}, $v$ : \kw{function}(\myref{PiThread}), $cont\_pc$ : \kw{int}) \\
  \pindent\kw{var} $newcommit$ : \myref{OutCommit} \\
  \>$newcommit \leftarrow$ \kw{new} OutCommit \\
  \>$newcommit.thread \leftarrow pt$ \\
  \>$newcommit.cont\_pc \leftarrow cont\_pc$ \\
  \>$newcommit.evalfunc \leftarrow v$ \\
  \>$newcommit.clock \leftarrow pt.clock$ \\
  \>$newcommit.clockval \leftarrow pt.clock.val$ \\
  \>$newcommit.channel \leftarrow c$ \\
  \>\myref{CommitListAdd}($pt.env[c].outcommits$, $newcommit$) \\
  \kw{endfunction}
\end{program}

\label{IsValidInCommit}
\algosection{Runtime : input commitment validation}
\begin{program}
  \kw{function} IsValidInCommit($commit$ : \myref{InCommit}) \\
  \pindent\kw{if} $commit.clock = commit.thread.clock$ \kw{then} \\
  \>\pindent\kw{if} $commit.clockval = commit.thread.clock.val$ \kw{then} \\
  \>\>\pindent \kw{return} \kw{true} \\
  \>\>\kw{endif} \\
  \>\kw{endif} \\
  \>\kw{return} \kw{false} \\
  \kw{endfunction}
\end{program}

\label{IsValidOutCommit}
\algosection{Runtime : output commitment validation}
\begin{program}
  \kw{function} IsValidOutCommit($commit$ : \myref{OutCommit}) \\
  \pindent\kw{if} $commit.clock = commit.thread.clock$ \kw{then} \\
  \>\pindent\kw{if} $commit.clockval = commit.thread.clock.val$ \kw{then} \\
  \>\>\pindent \kw{return} \kw{true} \\
  \>\>\kw{endif} \\
  \>\kw{endif} \\
  \>\kw{return} \kw{false} \\
  \kw{endfunction}
\end{program}


\label{CanAwake}
\algosection{Runtime : thread awake test}
\begin{program}
  \kw{function} CanAwake($thread$ : \myref{PiThread}, $commit$ : \myref{Commit}) \\
  \pindent\kw{if} \synchro{\kw{not} TryAcquire($thread.lock$)} \kw{then} \\
  \>\pindent\kw{return} CANNOT\_ACQUIRE \\
  \>\kw{endif} \\
  \>\kw{if} ($commit.clock \neq clock$) \kw{or} ($commit.clockval \neq commit.clock.val$) \kw{then} \\
  \>\pindent\synchro{Release($thread.lock$)} \\
  \>\>\kw{return} INVALID\_COMMITMENT \\
  \>\kw{endif} \\
  \>\kw{if} $thread.clock.val =$ MAX\_INT \kw{then} \\
  \>\pindent\kw{var} $oldclock \leftarrow thread.clock$ \\
  \>\>$thread.clock \leftarrow$ \kw{Null} \\
  \>\>ReclaimClock($oldclock$) \\
  \>\>$thread.clock \leftarrow$ \myref{GenerateClock()} \\
  \>\kw{else} \\
  \>\pindent$thread.clock.val \leftarrow thread.clock.val + 1$ \\
  \>\kw{endif} \\
  \>$thread.commit \leftarrow commit$ \\
  \>\synchro{Release($thread.lock$)} \\
  \>\kw{return} VALID\_COMMITMENT \\
  \kw{endfunction}
\end{program}

\label{Awake}
\algosection{Runtime : effective thread awake}
\begin{program}
  \kw{function} Awake($scheduler$ : \myref{Scheduler}, $thread$ : \myref{PiThread}) \\
  \pindent\kw{if} $thread.commit \neq commit$ \kw{then} \\
  \>\pindent Crash() \\
  \>\kw{endif} \\
  \>\synchro{\myref{WaitQueueFetch}($scheduler.wait, thread$)} \\
  \>$thread.commit \leftarrow$ \kw{null} \\
  \>$thread.pc \leftarrow commit.cont\_pc$ \\
  \>$thread.status \leftarrow$ STATUS\_RUN \\
  \>\synchro{\myref{ReadyQueuePush}($scheduler.ready, thread$)} \\
  \kw{endfunction}
\end{program}

\label{GenerateClock}
\algosection{Runtime : clock generation}
\begin{program}
  \kw{function} GenerateClock() \\
  \pindent\kw{var} $clock$ : \myref{Clock} \\
  \>$clock \leftarrow$ \kw{new} Clock \\
  \>$clock.val = 0$ \\
  \>\kw{return} $clock$ \\
  \kw{endfunction}
\end{program}

\label{ChannelIncrRefCount}
\algosection{Runtime : channel ref count incrementation}
\begin{program}
  \kw{function} ChannelIncrRefCount($chan$ : \myref{Channel}) \\
  \pindent\synchro{Acquire($chan.lock$)} \\
  \>$chan.globalrc \leftarrow chan.globalrc + 1$ \\
  \>\synchro{Release($chan.lock$)} \\
  \kw{endfunction}
\end{program}

\label{ChanneldDecRefCount}
\algosection{Runtime : channel ref count decrementation}
\begin{program}
  \kw{function} ChannelDecRefCount($chan$ : \myref{Channel}) \\
  \pindent\synchro{Acquire($chan.lock$)} \\
  \>$chan.globalrc \leftarrow chan.globalrc - 1$ \\
  \>\kw{if} $chan.globalrc = 0$ \kw{then} \\
  \>\pindent\synchro{Release($chan.lock$)} \\
  \>\> ReclaimChannel($chan$) \\
  \>\kw{else} \\
  \>\pindent\synchro{Release($chan.lock$)} \\
  \>\kw{endif} \\
  \kw{endfunction}
\end{program}

\label{Main}
\algosection{Runtime : program entry point}
\begin{program}
  \kw{procedure} Main($nb\_core\_threads$ : \kw{int}, $entrypoint$ : \kw{function}) \\
  \pindent\kw{var} $schedpool$ : \myref{SchedPool} \\
  \>$schedpool \leftarrow$ \kw{new} SchedPool \\
  \>$schedpool.waiting\_slaves \leftarrow 0$ \\
  \>$schedpool.running \leftarrow$ \kw{true} \\
  \>\\
  \>\kw{for} $i$ : \kw{int} \kw{from} $0$ \kw{to} $nb\_core\_threads - 1$ \\
  \>\pindent ThreadCreate($\myref{SchedulerSlave}, schedpool$) \\
  \>\>$schedpool.nb\_slaves \leftarrow schedpool.nb\_slaves + 1$ \\
  \>\kw{endfor} \\
  \>\\
  \>\kw{while} $schedpool.wait\_slaves \neq schedpool\_nb\_slaves$ \\
  \>\pindent\synchro{low\_level\_yield()} \\
  \>\kw{endwhile} \\
  \>\\
  \>\kw{var} $initthread$ : \myref{PiThread} \\
  \>$initthread \leftarrow$ \myref{GenerateThread}() \\
  \>$initthread.proc \leftarrow entrypoint$ \\
  \>$initthread.pc \leftarrow @entrypoint\_entry$ \\
  \>\\
  \>\myref{ReadyQueuePush}($schedpool.ready, initthread$) \\
  \>\myref{SchedulerMaster}($schedpool$) \\
  \kw{endprocedure}
\end{program}


\section{Scheduler}

\algosection{Scheduler datastructure}

\label{SchedPool}
\algosection{SchedPool}
\begin{program}
  \kw{record} SchedPool \{ \\
  \pindent ready : \synchro{\myref{ConcurrentReadyQueue}}[\myref{PiThread}], \\
  \> wait : \synchro{\myref{ConcurrentWaitQueue}}[\myref{PiThread}] \\
  \> \synchro{lock : Mutex} \\
  \> \synchro{cond : Condition} \\
  \> nb\_slaves : \kw{int} \\
  \> nb\_waiting\_slaves : \kw{int} \\
  \} \\ \\
  \myref{GC2} : SchedPool $\rightarrow$ \kw{boolean}
\end{program}


\label{SchedulerSlave}
\algosection{Runtime : slave scheduler}
\begin{program}
  \kw{procedure} SchedulerSlave($schedpool$ : \myref{SchedPool}) \\
  \pindent\kw{var} $current$ : \myref{PiThread} \\
  \>\kw{while} $schedpool.running$ \\
  \>\pindent\kw{while} ReadyQueueSize($schedpool.ready$) $\neq 0$ \\
  \>\>\pindent$current \leftarrow$ \synchro{\myref{ReadyQueuePop}($schedpool.ready$)} \\
  \>\>\>\kw{do} \\
  \>\>\>\pindent$current.proc$($schedpool, current$) \\
  \>\>\>\kw{while} $current.status =$ STATUS\_CALL \\
  \>\>\>\kw{if} $safe\_choice$ \kw{and} $current.status =$ STATUS\_BLOCKED \kw{then} \\
  \>\>\>\pindent Crash(DEADLOCK) \\
  \>\>\>\kw{endif} \\
  \>\>\kw{endwhile} \\
  \>\>\synchro{Acquire($schedpool.lock$)} \\
  \>\>$schedpool.nb\_waiting\_slaves \leftarrow schedpool.nb\_waiting\_slaves + 1$ \\
  \>\>\synchro{CondWait($schedpool.lock, schedpool.cond$)} \\
  \>\>$schedpool.nb\_waiting\_slaves \leftarrow schedpool.nb\_waiting\_slaves - 1$ \\
  \>\>\synchro{Release($schedpool.lock$)} \\
  \>\kw{endwhile} \\
  \kw{endprocedure}
\end{program}

\label{SchedulerMaster}
\algosection{Runtime : master scheduler}
\begin{program}
  \kw{procedure} SchedulerMaster($schedpool$ : \myref{SchedPool}, $std\_gc\_fuel$ : \kw{int}, $quick\_gc\_fuel$ : \kw{int}, $active\_factor$ : \kw{int}) \\
  \pindent\kw{var} $current$ : \myref{PiThread} \\
  \>\kw{var} $gc\_fuel$ : \kw{int} \\
  \>$gc\_fuel \leftarrow std\_gc\_fuel$ \\
  \>\\
  \> /* \kw{pre} : schedpool.running = true */ \\
  \>\kw{while} $schedpool.running$ \\
  \>\pindent\kw{while} ReadyQueueSize($schedpool.ready$) $\neq 0$ \\
  \>\>\pindent$current \leftarrow$ \synchro{\myref{ReadyQueuePop}($schedpool.ready$)} \\
  \>\>\>\kw{if} \myref{ReadyQueueSize}($schedpool.ready$) $\ge 1$ \kw{and} $schedpool.nb\_waiting\_slaves < schedpool.nb\_slaves$ \kw{then} \\
  \>\>\>\pindent\synchro{Acquire($schedpool.lock$)} \\
  \>\>\>\>\synchro{CondSignal($schedpool.lock, schedpool.cond$)} \\
  \>\>\>\>\synchro{Release($schedpool.lock$)} \\
  \>\>\>\kw{endif} \\
  \>\>\>\kw{do} \\
  \>\>\>\pindent$current.proc(schedpool, current)$ \\
  \>\>\>\kw{while} $current.status =$ STATUS\_CALL \\
  \>\>\>\kw{if} $safe\_choice$ \kw{and} $current.status =$ STATUS\_BLOCKED \kw{then} \\
  \>\>\>\pindent Crash(DEADLOCK) \\
  \>\>\>\kw{endif} \\
  \>\>\>\\
  \>\>\>$gc\_fuel \leftarrow gc\_fuel - 1$ \\
  \>\>\>\kw{if} $gc\_fuel = 0$ \kw{then} \\
  \>\>\>\pindent\kw{var} $maxactive$ : \kw{int} \\
  \>\>\>\>$maxactive \leftarrow$ WaitQueueMaxActive($schedpool.wait$) \\
  \>\>\>\>\kw{if} WaitQueueSize($schedpool.wait$) $> maxactive * active\_factor$ \kw{then} \\
  \>\>\>\>\pindent WaitQueueMaxActiveReset($schedpool.wait$) \\
  \>\>\>\>\>\kw{var} $gc\_ok$ : \kw{boolean} \\
  \>\>\>\>\>$gc\_ok \leftarrow$ GC2($schedpool$) \\
  \>\>\>\>\>\kw{if} \kw{not} $gc\_ok$ \kw{or} WaitQueueSize($schedpool.wait$) $> maxactive * active\_factor$ \kw{then} \\
  \>\>\>\>\>\pindent$gc\_fuel \leftarrow quick\_gc\_fuel$ \\
  \>\>\>\>\>\kw{else} \\
  \>\>\>\>\>\pindent$gc\_fuel \leftarrow std\_gc\_fuel$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\kw{endif} \\
  \>\>\kw{endwhile} \\
  \>\> \\
  \>\>\synchro{Acquire($schedpool.lock$)} \\
  \>\>\kw{if} $schedpool.nb\_waiting\_slaves = schedpool.nb\_slaves$ \kw{then} \\
  \>\>\pindent $schedpool.running \leftarrow$ \kw{false} \\
  \>\>\synchro{CondBroadcast($schedpool.lock, schedpool.cond$)} \\
  \>\>\kw{endif} \\
  \>\>\synchro{Release($schedpool.lock$)} \\
  \>\kw{endwhile} \\
  \kw{endprocedure}
\end{program}

\section{Thread queues implementation}

\algosection{ConcurrentReadyQueue implementation}

\label{ReadyQueuePush}
\begin{program}
  \kw{function} ReadyQueuePush($rq$ : ReadyQueue, $pt$ : PiThread) \\
  \pindent\synchro{Acquire($rq.lock$)} \\
  \>\kw{if} $rq.size = 0$ \kw{then} \\
  \>\pindent$rq.head \leftarrow pt$ \\
  \>\>$rq.tail \leftarrow pt$ \\
  \>\>$pt.next \leftarrow$ \kw{null} \\
  \>\kw{else} \\
  \>\pindent$pt.next \leftarrow rq.head$ \\
  \>\>$rq.head \leftarrow pt$ \\
  \>\kw{endif} \\
  \>$rq.size \leftarrow rq.size + 1$ \\
  \>\synchro{Release($rq.lock$)} \\
  \kw{endfunction}
\end{program}

\label{ReadyQueueAdd}
\begin{program}
  \kw{function} ReadyQueueAdd($rq$ : ReadyQueue, $pt$ : PiThread) \\
  \pindent\synchro{Acquire($rq.lock$)} \\
  \>\kw{if} $rq.size = 0$ \kw{then} \\
  \>\pindent$rq.head \leftarrow pt$ \\
  \>\>$rq.tail \leftarrow pt$ \\
  \>\>$pt.next \leftarrow$ \kw{null} \\
  \>\kw{else} \\
  \>\pindent$rq.tail.next \leftarrow pt$ \\
  \>\>$rq.tail \leftarrow pt$ \\
  \>\>$pt.next \leftarrow$ \kw{null} \\
  \>\kw{endif} \\
  \>$rq.size \leftarrow rq.size + 1$ \\
  \>\synchro{Release($rq.lock$)} \\
  \kw{endfunction}
\end{program}

\label{ReadyQueuePop}
\begin{program}
  \kw{function} ReadyQueuePop($rq$ : ReadyQueue) \\
  \pindent\synchro{Acquire($rq.lock$)} \\
  \>\kw{if} $rq.size = 0$ \kw{then} \\
  \>\pindent\synchro{Release($rq.lock$)} \\
  \>\>\kw{return} \kw{null} \\
  \>\kw{endif} \\
  \>\kw{var} $res$ : PiThread \\
  \>$res \leftarrow rq.head$ \\
  \>$rq.head \leftarrow res.next$ \\
  \>$rq.size \leftarrow rq.size - 1$ \\
  \>\synchro{Release($rq.lock$)} \\
  \>\kw{return} $res$ \\
  \kw{endfunction}
\end{program}

\label{ReadyQueueSize}
\begin{program}
  \kw{function} ReadyQueueSize($rq$ : ReadyQueue) \\
  \pindent\synchro{Acquire($rq.lock$)} \\
  \>\kw{var} $nb$ : \kw{int} \\
  \>$nb \leftarrow rq.size$ \\
  \>\synchro{Release($rq.lock$)} \\
  \>\kw{return} $nb$ \\
  \kw{endfunction}
\end{program}

\algosection{ConcurrentWaitQueue implementation}

\begin{program}
  /* The WaitQueue is made of two consecutives queues : the active queue and the old queue */
\end{program}

\label{WaitQueuePush}
\begin{program}
  \kw{function} WaitQueuePush($wq$ : WaitQueue, $pt$ : PiThread) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>\kw{if} $wq.active.size = 0$ \kw{then} \\
  \>\pindent$wq.active.head \leftarrow pt$ \\
  \>\>$wq.active.tail \leftarrow pt$ \\
  \>\>$pt.next \leftarrow wq.old.head$ \\
  \>\kw{else} \\
  \>\pindent$pt.next \leftarrow wq.active.head$ \\
  \>\>$wq.active.head \leftarrow pt$ \\
  \>\kw{endif} \\
  \>$wq.active.size = wq.active.size + 1$ \\
  \>\synchro{Release($wq.lock$)} \\
  \kw{endfunction}
\end{program}

\label{WaitQueueFetch}
\begin{program}
  \kw{function} WaitQueueFetch($wq$ : WaitQueue, $pt$ : PiThread) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>\kw{var} $zone$ : \{ACTIVE, OLD\} \\
  \>\kw{var} $current$ : PiThread \\
  \>\kw{var} $prev$ : PiThread \\
  \>$zone \leftarrow$ ACTIVE \\
  \>$current \leftarrow wq.active.head$ \\
  \>$prev \leftarrow$ \kw{null} \\
  \>\kw{if} $current =$ \kw{null} \kw{then} \\
  \>\pindent$zone \leftarrow$ OLD \\
  \>\>$current \leftarrow wq.old.head$ \\
  \>\kw{endif} \\
  \>\kw{while} $current \neq$ \kw{null} \\
  \>\pindent\kw{if} $current = pt$ \kw{then} \\
  \>\>\pindent\kw{if} $prev \neq$ \kw{null} \kw{then} \\
  \>\>\>\pindent$prev.next \leftarrow current.next$\\
  \>\>\>\kw{endif} \\
  \>\>\>\kw{if} $zone =$ ACTIVE \kw{then} \\
  \>\>\>\pindent\kw{if} $current = wq.active.head$ \kw{then} \\
  \>\>\>\>\pindent$wq.active.head \leftarrow current.next$ \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\>\kw{if} $current = wq.active.tail$ \kw{then} \\
  \>\>\>\>\pindent$wq.active.tail \leftarrow prev$ \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\>$wq.active.size \leftarrow wq.active.size - 1$ \\
  \>\>\>\kw{else} \\
  \>\>\>\pindent\kw{if} $current = wq.old.head$ \kw{then} \\
  \>\>\>\>\pindent$wq.old.head \leftarrow current.next$ \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\>\kw{if} $current = wq.old.tail$ \kw{then} \\
  \>\>\>\>\pindent$wq.old.tail \leftarrow prev$ \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\>$wq.old.size \leftarrow wq.old.size - 1$ \\
  \>\>\>\kw{endif} \\
  \>\>\>\synchro{Release($wq.lock$)} \\
  \>\>\>\kw{return} $current$ \\
  \>\>\kw{endif} \\
  \>\>$prev \leftarrow current$ \\
  \>\>$current \leftarrow current.next$ \\
  \>\>\kw{if} $zone =$ ACTIVE \kw{and} $current = wq.old.head$ \kw{then} \\
  \>\>\pindent$zone \leftarrow$ OLD \\
  \>\>\kw{endif} \\
  \>\kw{endwhile} \\
  \>\synchro{Release($wq.lock$)} \\
  \>\kw{return} \kw{null} \\
  \kw{endfunction}
\end{program}

\label{WaitQueuePushOld}
\begin{program}
  \kw{function} WaitQueuePushOld($wq$ : WaitQueue, $pt$ : PiThread) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>\kw{if} $wq.old.size = 0$ \kw{then} \\
  \>\pindent$wq.old.head \leftarrow pt$ \\
  \>\>$wq.old.tail \leftarrow pt$ \\
  \>\>$pt.next \leftarrow$ \kw{null} \\
  \>\kw{else} \\
  \>\pindent$pt.next \leftarrow wq.old.head$ \\
  \>\>$wq.old.head \leftarrow pt$ \\
  \>\kw{endif} \\
  \>kw{if} $wq.active.size \neq 0$ \kw{then} \\
  \>\pindent$wq.active.tail.next \leftarrow pt$ \\
  \>\kw{endif} \\
  \>$wq.old.size \leftarrow wq.old.size + 1$ \\
  \>\synchro{Release($wq.lock$)} \\
  \kw{endfunction}
\end{program}

\label{WaitQueuePopOld}
\begin{program}
  \kw{function} WaitQueuePopOld($wq$ : WaitQueue) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>\kw{if} $wq.old.size = 0$ \kw{then} \\
  \>\pindent\synchro{Release($rq.lock$)} \\
  \>\>\kw{return} \kw{null} \\
  \>\kw{endif} \\
  \>\kw{var} $res$ : PiThread \\
  \>$res \leftarrow wq.old.tail$ \\
  \>$wq.old.tail \leftarrow res.prev$ \\
  \>$wq.old.size \leftarrow wq.old.size - 1$ \\
  \>\synchro{Release($wq.lock$)} \\
  \>\kw{return} $res$ \\
  \kw{endfunction}
\end{program}

\label{WaitQueueSize}
\begin{program}
  \kw{function} WaitQueueSize($wq$ : WaitQueue) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>\kw{var} $nb$ : \kw{int} \\
  \>$nb \leftarrow wq.active.size$ \\
  \>$nb \leftarrow nb + wq.old.size$ \\
  \>\synchro{Release($wq.lock$)} \\
  \>\kw{return} $nb$ \\
  \kw{endfunction}
\end{program}

\label{WaitQueueMaxActive}
\begin{program}
  \kw{function} WaitQueueMaxActive($wq$ : WaitQueue) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>\kw{var} $nb$ : \kw{int} \\
  \>$nb \leftarrow wq.active.size$ \\
  \>\synchro{Release($wq.lock$)} \\
  \>\kw{return} $nb$ \\
  \kw{endfunction}
\end{program}

\label{WaitQueueMaxActiveReset}
\begin{program}
  \kw{function} WaitQueueMaxActiveReset($wq$ : WaitQueue) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>$wq.old.size \leftarrow wq.old.size + wq.active.size$ \\
  \>$wq.active.size \leftarrow 0$ \\
  \>$wq.old.head \leftarrow wq.active.head$ \\
  \>$wq.active.head \leftarrow$ \kw{null} \\
  \>$wq.active.tail \leftarrow$ \kw{null} \\
  \>\synchro{Release($wq.lock$)} \\
  \kw{endfunction}
\end{program}

\section{Garbage collector}

\label{GC2}
\algosection{Runtime : second generation garbage collector}
\begin{program}
  \kw{function} GC2($sched$ : \myref{SchedPool}) \\
  \pindent\kw{var} $clique$ : Set[\myref{PiThread}] \\
  \>$clique \leftarrow \{\}$ \\
  \>\kw{var} $candidate$ : \myref{PiThread} \\
  \>$candidate \leftarrow$ \synchro{\myref{WaitQueuePopOld}($sched$)} \\
  \>\kw{if} \synchro{\kw{not} TryAcquire($candidate.lock$)} \kw{then} \\
  \>\pindent\synchro{\myref{WaitQueuePush}($candidate$)} \\
  \>\>\kw{return} \kw{false} \\
  \>\kw{endif} \\
  \>\kw{var} $candidates$ : Set[\myref{PiThread}] \\
  \>$candidates \leftarrow \{\}$ \\
  \>\kw{var} $chans$ : Set[\myref{Channel}] \\
  \>$chans \leftarrow \{\}$ \\
  \>SetAdd($candidates, candidate$) \\
  \> \\
  \>\kw{do} \\
  \>\pindent$candidate \leftarrow$ SetChoose($candidates$) \\
  \>\>\kw{for} $commit$ : \myref{Commit} \kw{in} $candidate.commits$ \\
  \>\>\pindent\kw{var} $chan$ : \myref{Channel} \\
  \>\>\>$chan \leftarrow commit.channel$ \\
  \>\>\>\kw{var} $refs$ : \kw{int} \\
  \>\>\>$refs \leftarrow 1$ \\
  \>\>\>\kw{if} SetAdd($chans, chan$) \kw{then} \\
  \>\>\>\pindent\kw{if} \synchro{\kw{not} TryAcquire($chan$)} \kw{then} \\
  \>\>\>\>\pindent\kw{goto} $@abandon\_gc$ \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\kw{else} \\
  \>\>\>\pindent\kw{continue} \\
  \>\>\>\kw{endif} \\
  \>\>\>\kw{for} $incommit$ : \myref{Commit} \kw{in} $chan.incommits$ \\
  \>\>\>\pindent\kw{if} \myref{IsValidInCommit}($incommit$) \kw{then} \\
  \>\>\>\>\>\kw{if} \synchro{\kw{not} TryAcquire($incommit.thread.lock$)} \kw{then} \\
  \>\>\>\>\>\pindent\synchro{\myref{WaitQueuePush}($sched.wait, incommit.thread$)} \\
  \>\>\>\>\>\>\kw{goto} $@abandon\_gc$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\pindent\kw{if} $incommit.thread.status \neq$ STATUS\_WAIT \kw{then} \\
  \>\>\>\>\>\pindent\kw{goto} $@abandon\_gc$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\>\synchro{\myref{WaitQueueFetch}($sched.wait, incommit.thread$)} \\
  \>\>\>\>\>\kw{if} SetAdd($candidates, incommit.thread$) \kw{then} \\
  \>\>\>\>\>\pindent$refs \leftarrow refs + 1$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\kw{else} \\
  \>\>\>\>\pindent RemoveInCommit() \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\kw{endfor} \\
  \>\>\>\kw{for} $outcommit$ : \myref{Commit} \kw{in} $chan.outcommits$ \\
  \>\>\>\pindent\kw{if} \myref{IsValidOutCommit}($outcommit$) \kw{then} \\
  \>\>\>\>\pindent\kw{if} $outcommit.thread.status \neq$ STATUS\_WAIT \kw{then} \\
  \>\>\>\>\>\pindent\kw{goto} $@abandon\_gc$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\>\synchro{\myref{WaitQueuePop}($sched.wait, outcommit.thread$)} \\
  \>\>\>\>\>\kw{if} \synchro{\kw{not} TryAcquire($outcommit.thread.lock$)} \kw{then} \\
  \>\>\>\>\>\pindent\synchro{\myref{WaitQueuePush}($sched.wait, outcommit.thread$)} \\
  \>\>\>\>\>\>\kw{goto} $@abandon\_gc$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\>\kw{if} SetAdd($candidates, outcommit.thread$) \kw{then} \\
  \>\>\>\>\>\pindent$refs \leftarrow refs + 1$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\kw{else} \\
  \>\>\>\>\pindent RemoveOutCommit() \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\kw{endfor} \\
  \>\>\> \\
  \>\>\>\kw{if} $refs < chan.globalrc$ \kw{then} \\
  \>\>\>\pindent\kw{goto} $@abandon\_gc$ \\
  \>\>\>\kw{endif} \\
  \>\>\kw{endfor} \\
  \>\>SetAdd($clique, candidate$) \\
  \>\kw{while} SetSize($candidates$) $> 0$ \\
  \> \\
  \>\kw{for} $deadthread$ : \myref{PiThread} \kw{in} $clique$ \\
  \>\pindent ReclaimPiThread($deadthread$) \\
  \>\kw{endif} \\
  \>\kw{return} \kw{true} \\
  \> \\
  \>$@abandon\_gc$ \\
  \>\kw{for} $thread$ : \myref{PiThread} \kw{in} $clique$ \\
  \>\pindent\synchro{\myref{WaitQueuePush}($sched.wait, thread$)} \\
  \>\>\synchro{Release($thread.lock$)} \\
  \>\kw{endfor} \\
  \>\kw{for} $thread$ : \myref{PiThread} \kw{in} $candidates$ \\
  \>\pindent\synchro{\myref{WaitQueuePush}($sched.wait, thread$)} \\
  \>\>\synchro{Release($thread.lock$)} \\
  \>\kw{endfor} \\
  \>\synchro{ReleaseAllChannels($chans$)} \\
  \>\kw{return} \kw{false} \\
  \kw{endfunction}
\end{program}

\end{document}
