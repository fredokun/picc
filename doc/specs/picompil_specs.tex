\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{graphicx}
\usepackage[pdfborder = {0 0 0}]{hyperref}

\definecolor{compilecolor}{gray}{0.45}
\definecolor{synchrocolor}{rgb}{0.1, 0.2, 0.8}
\title{PiThread Compiler Specifications}
\date{\today}
\author{AurÃ©lien Deharbe and Fr\'ed\'eric Peschanski\\ UPMC -- LIP6 -- APR}

\newenvironment{program}{
  \begin{sffamily}
  \begin{scriptsize}
  \begin{tabbing}}
 {\end{tabbing}
  \end{scriptsize}
  \end{sffamily}}

\newcommand{\kw}[1]{\textsf{\textbf{#1}}}
\newcommand{\pindent}{\hspace{2em}\=}
\newcommand{\compiletime}[1]{\textcolor{compilecolor}{#1}}
\newcommand{\synchro}[1]{\textcolor{synchrocolor}{#1}}

\newcommand{\algotitle}[1]{\noindent\\ \noindent#1\par\nobreak\vspace{3pt}\hrule\vspace{6pt}}
\newcommand{\algosection}[1]{
  \phantomsection
  \addcontentsline{toc}{subsection}{#1}
  \algotitle{#1}
}
\newcommand{\myref}[1]{
  \hyperref[#1]{#1}
}

\begin{document}

\renewcommand{\contentsname}{Table of contents}
\maketitle
$ $\newline
$ $\newline
\begin{center}
\includegraphics[scale=0.45]{pithreads.png}
\end{center}
\newpage
\tableofcontents
\newpage

%%%%%%%%%%%%%%% Section COMMENTS %%%%%%%%%%%%%%%%%%
\section{Comments}

\noindent
\begin{itemize}
\item \footnotesize Colors :
  \begin{itemize}
  \item \compiletime{Instructions in grey are compilation time.}
  \item Instructions in black are runtime.
  \item \synchro{Instructions in blue are related to thread synchronization.}
  \end{itemize}
\item \footnotesize Runtime environment notation :
  \begin{itemize}
  \item $pt.env[i]$ access to $i^{th}$ element of env when $i$ is an integer.
  \item $pt.env[v]$ is a shortcut to access to $i^{th}$ element of env with $i$ being the index of var $v$ (index solved in the compilation environment).
  \end{itemize}
\item \footnotesize The $eval$ function defined in the guarded choice, for lazy expression evaluation of output, is not a closure.
\end{itemize}


%%%%%%%%%%%%%%% Section DATA STRUCTURES %%%%%%%%%%%
\section{Data structures and operations}

\label{SchedPool}
\algosection{SchedPool}
\begin{program}
  \kw{record} SchedPool \{ \\
  \pindent ready : \synchro{\myref{ConcurrentReadyQueue}}[\myref{PiThread}], \\
  \> wait : \synchro{\myref{ConcurrentWaitQueue}}[\myref{PiThread}] \\
  \> \synchro{lock : Mutex} \\
  \> \synchro{cond : Condition} \\
  \> nb\_slaves : \kw{int} \\
  \> nb\_waiting\_slaves : \kw{int} \\
  \} \\ \\
  \myref{GC2} : SchedPool $\rightarrow$ \kw{boolean}
\end{program}

\label{PiThread}
\algosection{PiThread}
\begin{program}
  \kw{record} PiThread \{ \\
  \pindent status : \{STATUS\_RUN, STATUS\_CALL, STATUS\_WAIT, STATUS\_ENDED\}, \\
  \> enabled : Array[\kw{boolean}], \\
  \> knows : \myref{KnowsSet}[\myref{Channel}], \\
  \> env : Array[Object], \\
  \> commit : Commit \\
  \> commits : Set[Commit] \\
  \> proc : \kw{function}, \\
  \> pc : \kw{label}, \\
  \> val : Value, \\
  \> clock : \myref{Clock} \\
  \> fuel : \kw{int} \\
  \> \synchro{lock : Mutex} \\
  \} \\ \\
  \myref{CanAwake} : \myref{PiThread} x \myref{Commit} $\rightarrow$ \kw{boolean} \\
  \myref{Awake} : \myref{SchedPool} x \myref{PiThread} x Commit $\rightarrow$ \kw{void}
\end{program}

\newpage

\label{Channel}
\algosection{Channel}
\begin{program}
  \kw{record} Channel \{ \\
  \pindent incommits : \myref{CommitList}[\myref{InCommit}] \\
  \>outcommits : \myref{CommitList}[\myref{OutCommit}] \\
  \>globalrc : \kw{int} \\
  \>\synchro{lock : AtomicBoolean} \\
  \} \\ \\
  \myref{RegisterOutputCommitment} : \myref{PiThread} x \myref{Channel} \kw{var} x Expr x \kw{dynLabel} $\rightarrow$ \kw{void} \\
  \myref{RegisterInputCommitment} : \myref{PiThread} x \myref{Channel} \kw{var} x Env \kw{var} x \kw{dynLabel} $\rightarrow$ \kw{void} \\
  \myref{FetchOutputCommitment} : \myref{PiThread} x \myref{Channel} \kw{var} $\rightarrow$ \myref{OutCommit} \\
  \myref{FetchInputCommitment} : \myref{PiThread} x \myref{Channel} \kw{var} $\rightarrow$ \myref{InCommit} \\
  \myref{ChannelIncrRefCount} : \myref{Channel} $\rightarrow$ \kw{void} \\
  \myref{ChannelDecRefCount} : \myref{Channel} $\rightarrow$ \kw{void}
\end{program}

\label{InCommit}
\algosection{Input Commitment}
\begin{program}
  \kw{record} InCommit \{ \\
  \pindent thread : \myref{PiThread}, \\
  \>refvar : \kw{int}, \\
  \>clock : \myref{Clock} \\
  \>clockval : \kw{int} \\
  \>cont\_pc : \kw{int} \\
  \>channel : \myref{Channel} \\
  \} \\ \\
  \myref{IsValidInCommit} : \myref{InCommit} $\rightarrow$ \kw{boolean}
\end{program}

\label{OutCommit}
\algosection{Output Commitment}
\begin{program}
  \kw{record} OutCommit \{ \\
  \pindent thread : \myref{PiThread}, \\
  \>evalfunc : \kw{function}(\myref{PiThread}), \\
  \>clock : \myref{Clock} \\
  \>clockval : \kw{int} \\
  \>cont\_pc : \kw{int} \\
  \>channel : \myref{Channel} \\
  \} \\ \\
  \myref{IsValidOutCommit} : \myref{OutCommit} $\rightarrow$ \kw{boolean}
\end{program}

\label{Clock}
\algosection{Clock}
\begin{program}
  \kw{record} Clock \{ \\
  \pindent val : AtomicInt \\
  \}
\end{program}

\newpage

\algosection{CommitList}
\begin{program}
  /* CommitListAdd add the selected element at the end of the CommitList */ \\
  \kw{abstract} CommitListAdd : CommitList x Commit $\rightarrow$ \kw{void} \\ \\
  /* CommitListFetch removes the first element from the CommitList and returns it */ \\
  \kw{abstract} CommitListFetch : CommitList $\rightarrow$ Commit
\end{program}

\algosection{ConcurrentReadyQueue}
\begin{program}
  /* ReadyQueuePush push a PiThread on the top of a ReadyQueue */ \\
  \myref{ReadyQueuePush} : ReadyQueue x \myref{PiThread} $\rightarrow$ \kw{void} \\ \\
  /* ReadyQueueAdd add a PiThread at the end of a ReadyQueue */ \\
  \myref{ReadyQueueAdd} : ReadyQueue x \myref{PiThread} $\rightarrow$ \kw{void} \\ \\
  /* ReadyQueuePop pop a PiThread from the top of a ReadyQueue */ \\
  \myref{ReadyQueuePop} : ReadyQueue $\rightarrow$ \myref{PiThread} \\ \\
  /* ReadyQueueSize returns the number of elements in a ReadyQueue */ \\
  \myref{ReadyQueueSize} : ReadyQueue $\leftarrow$ \kw{int}
\end{program}

\algosection{ConcurrentWaitQueue}
\begin{program}
  /* WaitQueuePush pushes a PiThread at the top of a WaitQueue */ \\
  \myref{WaitQueuePush} : WaitQueue x \myref{PiThread} $\rightarrow$ \kw{void} \\ \\
  /* WaitQueueFetch pop a selected PiThread from a WaitQueue */ \\
  \myref{WaitQueueFetch} : WaitQueue x \myref{PiThread} $\rightarrow$ \myref{PiThread} \\ \\
  /* WaitQueuePushOld pushes a PiThread at the top of the old PiThreads in a WaitQueue */ \\
  \myref{WaitQueuePushOld} : WaitQueue x \myref{PiThread} $\rightarrow$ \kw{void} \\ \\
  /* WaitQueuePopOld pop the older PiThread from a WaitQueue */ \\
  \myref{WaitQueuePopOld} : WaitQueue $\rightarrow$ \myref{PiThread} \\ \\
  /* WaitQueueSize returns the number of elements in a WaitQueue */ \\
  \myref{WaitQueueSize} : WaitQueue $\rightarrow$ \kw{int} \\ \\
  /* WaitQueueMaxActive returns the number of active elements in a WaitQueue */ \\
  \myref{WaitQueueMaxActive} : WaitQueue $\rightarrow$ \kw{int} \\ \\
  /* WaitQueueMaxActiveReset reset the counter of active elements in a WaitQueue (i.e. active elements are now old elements) */ \\
  \myref{WaitQueueMaxActiveReset} : WaitQueue $\rightarrow$ \kw{int}
\end{program}

\newpage

\algosection{KnowsSet}
\begin{program}
  \kw{type} KnowsState : \{UNKNOWN, KNOWN, FORGET\} \\ \\
  /* KnowsSetKnows returns a subset of all KNOWN-state in a KnowsSet */ \\
  \kw{abstract} KnowsSetKnows : KnowsSet $\rightarrow$ KnowsSet \\ \\
  /* KnowsSetForget returns a subset of all FORGET-state in a KnowsSet */ \\
  \kw{abstract} KnowsSetForget : KnowsSet $\rightarrow$ KnowsSet \\ \\
  /* KnowsSetForgetToUnknown switches an element of a KnowsSet from the FORGET-State to the UNKNOWN-state */ \\
  \kw{abstract} KnowsSetForgetToUnknown : KnowsSet x \myref{Channel} \kw{var} $\rightarrow$ \kw{void} \\ \\
  /* KnowsSetForgetAll switches all KNOWN-state elements of a KnowsSet to FORGET-state */ \\
  \kw{abstract} KnowsSetForgetAll : KnowsSet $\rightarrow$ \kw{void} \\ \\
  /* KnowsRegister looks for a channel in a KnowsSet : \\
  \pindent * if the channel is in the KnowsSet in KNOWN-state, it returns false \\
  \> * if the channel is in the KnowsSet in FORGET-state, it switches it to KNOWN then returns false \\
  \> * else it adds the channel in the KnowsSet (KNOWS-state) then returns true */ \\
  \kw{abstract} KnowsRegister : KnowsSet x \myref{Channel} \kw{var} $\rightarrow$ \kw{boolean}
\end{program}

\newpage

\section{Thread queues implementation}

\algosection{ConcurrentReadyQueue implementation}

\label{ReadyQueuePush}
\begin{program}
  \kw{function} ReadyQueuePush($rq$ : ReadyQueue, $pt$ : PiThread) \\
  \pindent\synchro{Acquire($rq.lock$)} \\
  \>\kw{if} $rq.size = 0$ \kw{then} \\
  \>\pindent$rq.head \leftarrow pt$ \\
  \>\>$rq.tail \leftarrow pt$ \\
  \>\>$pt.next \leftarrow$ \kw{null} \\
  \>\kw{else} \\
  \>\pindent$pt.next \leftarrow rq.head$ \\
  \>\>$rq.head \leftarrow pt$ \\
  \>\kw{endif} \\
  \>$rq.size \leftarrow rq.size + 1$ \\
  \>\synchro{Release($rq.lock$)} \\
  \kw{endfunction}
\end{program}

\label{ReadyQueueAdd}
\begin{program}
  \kw{function} ReadyQueueAdd($rq$ : ReadyQueue, $pt$ : PiThread) \\
  \pindent\synchro{Acquire($rq.lock$)} \\
  \>\kw{if} $rq.size = 0$ \kw{then} \\
  \>\pindent$rq.head \leftarrow pt$ \\
  \>\>$rq.tail \leftarrow pt$ \\
  \>\>$pt.next \leftarrow$ \kw{null} \\
  \>\kw{else} \\
  \>\pindent$rq.tail.next \leftarrow pt$ \\
  \>\>$rq.tail \leftarrow pt$ \\
  \>\>$pt.next \leftarrow$ \kw{null} \\
  \>\kw{endif} \\
  \>$rq.size \leftarrow rq.size + 1$ \\
  \>\synchro{Release($rq.lock$)} \\
  \kw{endfunction}
\end{program}

\label{ReadyQueuePop}
\begin{program}
  \kw{function} ReadyQueuePop($rq$ : ReadyQueue) \\
  \pindent\synchro{Acquire($rq.lock$)} \\
  \>\kw{if} $rq.size = 0$ \kw{then} \\
  \>\pindent\synchro{Release($rq.lock$)} \\
  \>\>\kw{return} \kw{null} \\
  \>\kw{endif} \\
  \>\kw{var} $res$ : PiThread \\
  \>$res \leftarrow rq.head$ \\
  \>$rq.head \leftarrow res.next$ \\
  \>$rq.size \leftarrow rq.size - 1$ \\
  \>\synchro{Release($rq.lock$)} \\
  \>\kw{return} $res$ \\
  \kw{endfunction}
\end{program}

\label{ReadyQueueSize}
\begin{program}
  \kw{function} ReadyQueueSize($rq$ : ReadyQueue) \\
  \pindent\synchro{Acquire($rq.lock$)} \\
  \>\kw{var} $nb$ : \kw{int} \\
  \>$nb \leftarrow rq.size$ \\
  \>\synchro{Release($rq.lock$)} \\
  \>\kw{return} $nb$ \\
  \kw{endfunction}
\end{program}

\algosection{ConcurrentWaitQueue implementation}

\begin{program}
  /* The WaitQueue is made of two consecutives queues : the active queue and the old queue */
\end{program}

\label{WaitQueuePush}
\begin{program}
  \kw{function} WaitQueuePush($wq$ : WaitQueue, $pt$ : PiThread) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>\kw{if} $wq.active.size = 0$ \kw{then} \\
  \>\pindent$wq.active.head \leftarrow pt$ \\
  \>\>$wq.active.tail \leftarrow pt$ \\
  \>\>$pt.next \leftarrow wq.old.head$ \\
  \>\kw{else} \\
  \>\pindent$pt.next \leftarrow wq.active.head$ \\
  \>\>$wq.active.head \leftarrow pt$ \\
  \>\kw{endif} \\
  \>$wq.active.size = wq.active.size + 1$ \\
  \>\synchro{Release($wq.lock$)} \\
  \kw{endfunction}
\end{program}

\label{WaitQueueFetch}
\begin{program}
  \kw{function} WaitQueueFetch($wq$ : WaitQueue, $pt$ : PiThread) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>\kw{var} $zone$ : \{ACTIVE, OLD\} \\
  \>\kw{var} $current$ : PiThread \\
  \>\kw{var} $prev$ : PiThread \\
  \>$zone \leftarrow$ ACTIVE \\
  \>$current \leftarrow wq.active.head$ \\
  \>$prev \leftarrow$ \kw{null} \\
  \>\kw{if} $current =$ \kw{null} \kw{then} \\
  \>\pindent$zone \leftarrow$ OLD \\
  \>\>$current \leftarrow wq.old.head$ \\
  \>\kw{endif} \\
  \>\kw{while} $current \neq$ \kw{null} \\
  \>\pindent\kw{if} $current = pt$ \kw{then} \\
  \>\>\pindent\kw{if} $prev \neq$ \kw{null} \kw{then} \\
  \>\>\>\pindent$prev.next \leftarrow current.next$\\
  \>\>\>\kw{endif} \\
  \>\>\>\kw{if} $zone =$ ACTIVE \kw{then} \\
  \>\>\>\pindent\kw{if} $current = wq.active.head$ \kw{then} \\
  \>\>\>\>\pindent$wq.active.head \leftarrow current.next$ \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\>\kw{if} $current = wq.active.tail$ \kw{then} \\
  \>\>\>\>\pindent$wq.active.tail \leftarrow prev$ \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\>$wq.active.size \leftarrow wq.active.size - 1$ \\
  \>\>\>\kw{else} \\
  \>\>\>\pindent\kw{if} $current = wq.old.head$ \kw{then} \\
  \>\>\>\>\pindent$wq.old.head \leftarrow current.next$ \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\>\kw{if} $current = wq.old.tail$ \kw{then} \\
  \>\>\>\>\pindent$wq.old.tail \leftarrow prev$ \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\>$wq.old.size \leftarrow wq.old.size - 1$ \\
  \>\>\>\kw{endif} \\
  \>\>\>\synchro{Release($wq.lock$)} \\
  \>\>\>\kw{return} $current$ \\
  \>\>\kw{endif} \\
  \>\>$prev \leftarrow current$ \\
  \>\>$current \leftarrow current.next$ \\
  \>\>\kw{if} $zone =$ ACTIVE \kw{and} $current = wq.old.head$ \kw{then} \\
  \>\>\pindent$zone \leftarrow$ OLD \\
  \>\>\kw{endif} \\
  \>\kw{endwhile} \\
  \>\synchro{Release($wq.lock$)} \\
  \>\kw{return} \kw{null} \\
  \kw{endfunction}
\end{program}

\label{WaitQueuePushOld}
\begin{program}
  \kw{function} WaitQueuePushOld($wq$ : WaitQueue, $pt$ : PiThread) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>\kw{if} $wq.old.size = 0$ \kw{then} \\
  \>\pindent$wq.old.head \leftarrow pt$ \\
  \>\>$wq.old.tail \leftarrow pt$ \\
  \>\>$pt.next \leftarrow$ \kw{null} \\
  \>\kw{else} \\
  \>\pindent$pt.next \leftarrow wq.old.head$ \\
  \>\>$wq.old.head \leftarrow pt$ \\
  \>\kw{endif} \\
  \>kw{if} $wq.active.size \neq 0$ \kw{then} \\
  \>\pindent$wq.active.tail.next \leftarrow pt$ \\
  \>\kw{endif} \\
  \>$wq.old.size \leftarrow wq.old.size + 1$ \\
  \>\synchro{Release($wq.lock$)} \\
  \kw{endfunction}
\end{program}

\label{WaitQueuePopOld}
\begin{program}
  \kw{function} WaitQueuePopOld($wq$ : WaitQueue) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>\kw{if} $wq.old.size = 0$ \kw{then} \\
  \>\pindent\synchro{Release($rq.lock$)} \\
  \>\>\kw{return} \kw{null} \\
  \>\kw{endif} \\
  \>\kw{var} $res$ : PiThread \\
  \>$res \leftarrow wq.old.tail$ \\
  \>$wq.old.tail \leftarrow res.prev$ \\
  \>$wq.old.size \leftarrow wq.old.size - 1$ \\
  \>\synchro{Release($wq.lock$)} \\
  \>\kw{return} $res$ \\
  \kw{endfunction}
\end{program}

\label{WaitQueueSize}
\begin{program}
  \kw{function} WaitQueueSize($wq$ : WaitQueue) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>\kw{var} $nb$ : \kw{int} \\
  \>$nb \leftarrow wq.active.size$ \\
  \>$nb \leftarrow nb + wq.old.size$ \\
  \>\synchro{Release($wq.lock$)} \\
  \>\kw{return} $nb$ \\
  \kw{endfunction}
\end{program}

\label{WaitQueueMaxActive}
\begin{program}
  \kw{function} WaitQueueMaxActive($wq$ : WaitQueue) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>\kw{var} $nb$ : \kw{int} \\
  \>$nb \leftarrow wq.active.size$ \\
  \>\synchro{Release($wq.lock$)} \\
  \>\kw{return} $nb$ \\
  \kw{endfunction}
\end{program}

\label{WaitQueueMaxActiveReset}
\begin{program}
  \kw{function} WaitQueueMaxActiveReset($wq$ : WaitQueue) \\
  \pindent\synchro{Acquire($wq.lock$)} \\
  \>$wq.old.size \leftarrow wq.old.size + wq.active.size$ \\
  \>$wq.active.size \leftarrow 0$ \\
  \>$wq.old.head \leftarrow wq.active.head$ \\
  \>$wq.active.head \leftarrow$ \kw{null} \\
  \>$wq.active.tail \leftarrow$ \kw{null} \\
  \>\synchro{Release($wq.lock$)} \\
  \kw{endfunction}
\end{program}

\newpage

%%%%%%%%%%%%%%% Section COMPILATION %%%%%%%%%%%%%%%
\section{Compilation outlines and runtime functions}

\label{CompileExpr}
\algosection{Compilation outline for constants}
\begin{program}
  \compiletime{CompileExpr(\kw{true}) $\rightarrow$} \\
  $pt.val \leftarrow$ \kw{true}
\end{program}

\begin{program}
  \compiletime{CompileExpr(\kw{false}) $\rightarrow$} \\
  $pt.val \leftarrow$ \kw{false}
\end{program}

\algosection{Compilation outline for var}
\begin{program}
  \compiletime{CompileExpr($v$ : \kw{var}) $\rightarrow$} \\
  $pt.val \leftarrow pt.env[v]$
\end{program}

\algosection{Compilation outline for unary operators}
\begin{program}
  \compiletime{CompileExpr(\kw{op} $b$) $\rightarrow$} \\
  \compiletime{CompileExpr($b$)} \\
  $pt.val \leftarrow$ \kw{op} $pt.val$
\end{program}

\algosection{Compilation outline for binary operators}
\begin{program}
  \compiletime{CompileExpr($a$ \kw{and} $b$) $\rightarrow$} \\
  \compiletime{CompileExpr($a$)} \\
  \kw{if} $pt.val$ \kw{then} \\
  \pindent\compiletime{CompileExpr($b$)} \\
  \kw{endif}
\end{program}

\begin{program}
  \compiletime{CompileExpr($a$ \kw{or} $b$) $\rightarrow$} \\
  \compiletime{CompileExpr($a$)} \\
  \kw{if} \kw{not} $pt.val$ \kw{then} \\
  \pindent\compiletime{CompileExpr($b$)} \\
  \kw{endif}
\end{program}

\begin{program}
  \compiletime{CompileExpr($a$ \kw{op} $b$) $\rightarrow$} \\
  \kw{begin} \\
  \pindent\compiletime{CompileExpr($a$)} \\
  \>\kw{var} $temp$ : \kw{Value} \\
  \>$temp \leftarrow pt.val$ \\
  \>\compiletime{CompileExpr($b$)} \\
  \>$pt.val \leftarrow pt.val$ \kw{op} $temp$ \\
  \kw{end}
\end{program}

\newpage

\algosection{Compilation outline for definition}
\begin{program}
  \compiletime{Compile(\kw{def} $D(x_1, ..., x_n) = P$) $\rightarrow$} \\ \\
  \compiletime{\kw{cvar} $D\_entry$ : \kw{DynLabel}} \\
  \compiletime{$D\_entry \leftarrow$ GenerateLabel()} \\
  \kw{function} $D$(\myref{SchedPool} $scheduler$, \myref{PiThread} $pt$) \{ \\
  \pindent\kw{switch} $pt.pc$ \{ \\
  \>\kw{case} $@D\_entry:$ \\
  \>\pindent\compiletime{Compile($P$)} \\
  \>\} \\
  \}
\end{program}

\algosection{Compilation outline for termination}
\begin{program}
  \compiletime{Compile(\kw{end}, $status$) $\rightarrow$} \\ \\
  \kw{foreach} $chan$ : \myref{Channel} in \myref{KnowsSetKnows}($pt.knows$) \\
  \pindent\myref{ChannelDecRefCount}($chan$) \\
  \kw{endfor} \\
  \kw{foreach} $chan$ : \myref{Channel} in \myref{KnowsSetForget}($pt.knows$) \\
  \pindent\myref{ChannelDecRefCount}($chan$) \\
  \kw{endfor} \\
  $pt.status \leftarrow status$ \\
  \kw{return}
\end{program}

\algosection{Compilation outline for call}
\begin{program}
  \compiletime{Compile($D(v_1$:T$_1, ..., v_n$:T$_n)) \rightarrow$} \\ \\
  \kw{begin} \\
  \pindent\kw{var} $args$ : Array[$n$ * Value] \\
  \>\myref{KnowsSetForgetAll}($pt.knows$) \\
  \>\\
  \>\compiletime{\kw{cfor} $i$ : \kw{int} \kw{from} $0$ \kw{to} $n-1$} \\
  \>\pindent\compiletime{\myref{CompileExpr}($v_{i+1}$)} \\
  \>\>$args[i] \leftarrow pt.val$ \\
  \>\compiletime{\kw{cendfor}} \\
  \>\\
  \>\compiletime{\kw{cfor} $i$ : \kw{int} \kw{from} $0$ \kw{to} $n-1$} \\
  \>\pindent $pt.env[i] \leftarrow args[i]$ \\
  \>\>\compiletime{\kw{cif} ischannel(T$_{i+1}$) \kw{then}} \\
  \>\>\pindent\myref{KnowsRegister}($pt.knows, args[i]$) \\
  \>\>\compiletime{\kw{cendif}} \\
  \>\compiletime{\kw{cendfor}} \\
  \>\\
  \>$pt.proc \leftarrow D$ \\
  \>$pt.pc \leftarrow @D\_entry$ \\
  \>$pt.status \leftarrow$ STATUS\_CALL \\
  \>\kw{return} \\
  \kw{end}
\end{program}

\newpage

\label{CompileWait}
\algosection{Compilation outline for wait}
\begin{program}
  \compiletime{CompileWait($chans$ : \kw{Set}[\kw{record} Channel]) $\rightarrow$} \\ \\
  /* \kw{property} : $chans \cap knows.FORGET = \{\}$ */ \\
  $pt.pc \leftarrow$ INVALID\_PC \\
  $pt.fuel \leftarrow$ FUEL\_INIT \\
  \kw{foreach} $chan$ : \myref{Channel} in \myref{KnowsSetForget}($pt.knows$) \\
  \pindent\myref{ChannelDecRefCount}($chan$) \\
  \>\myref{KnowsSetForgetToUnknown}($pt.knows, chan$) \\
  \kw{endfor} \\
  $pt.status \leftarrow$ STATUS\_WAIT \\
  \synchro{\myref{WaitQueuePush}($scheduler.wait$, $pt$)} \\
  \synchro{Release($pt.lock$)} \\
  \kw{return}
\end{program}



\label{CompileYield}
\algosection{Compilation outline for yield}
\begin{program}
  \compiletime{CompileYield($label\_cont$) $\rightarrow$} \\ \\
  $pt.pc \leftarrow @label\_cont$ \\
  $pt.fuel \leftarrow$ FUEL\_INIT \\
  \kw{foreach} $chan$ : \myref{Channel} in \myref{KnowsSetForget}($pt.knows$) \\
  \pindent\myref{ChannelDecRefCount}($chan$) \\
  \>\myref{KnowsSetForgetToUnknown}($pt.knows, chan$) \\
  \kw{endfor} \\
  \synchro{\myref{ReadyQueueAdd}($scheduler.ready, pt$)} \\
  \kw{return}
\end{program}

\newpage

\algosection{Compilation outline for guarded choice}
\begin{program}
  \compiletime{Compile($\sum_{i=0}^{n-1}[g_i]\alpha_i.P_i$) $\rightarrow$} \\ \\
  \kw{begin} \\
  \pindent\kw{var} $tryresult$ : \{ENABLED, DISABLED, COMMIT\} \\
  \>\kw{var} $nbdisabled$ : \kw{int} \\
  \>$nbdisabled \leftarrow 0$ \\
  \>\compiletime{\kw{cvar} $choice\_cont$ : Array[\kw{dynLabel}]} \\
  \>\kw{var} $chans$ : Set[\myref{Channel}] \\
  \>$chans \leftarrow \{\}$ \\
  \>\compiletime{\kw{cfor} $i$ : \kw{int} \kw{from} $0$ \kw{to} $n-1$} \\
  \>\pindent\compiletime{$choice\_cont[i] \leftarrow$ GenerateLabel()} \\
  \>\>\compiletime{\myref{CompileExpr}($g_i$)} \\
  \>\>$pt.enabled[i] \leftarrow pt.val$ \\
  \>\>\kw{if} $pt.enabled[i]$ \kw{then} \\
  \>\>\pindent\compiletime{\myref{CompileTryAction}($\alpha_i, chans$)} \\
  \>\>\>\kw{if} $tryresult =$ DISABLED \kw{then} \\
  \>\>\>\pindent$pt.enabled[i] \leftarrow$ \kw{false} \\
  \>\>\>\>$nbdisabled \leftarrow nbdisabled + 1$ \\
  \>\>\>\kw{else} \kw{if} $tryresult =$ ENABLED \kw{then} \\
  \>\>\>\pindent$pt.fuel \leftarrow pt.fuel - 1$ \\
  \>\>\>\>\kw{if} $pt.fuel = 0$ \kw{then} \\
  \>\>\>\>\pindent\synchro{\myref{ReleaseAllChannels}($chans$)} \\
  \>\>\>\>\>\compiletime{\myref{CompileYield}($choice\_cont[i]$)} \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\>\kw{goto} $@choice\_cont[i]$ \\
  \>\>\>\kw{endif} \\
    \>\>\kw{else} \\
  \>\>\pindent$nbdisabled \leftarrow nbdisabled + 1$ \\
  \>\>\kw{endif} \\
  \>\compiletime{\kw{cendfor}} \\
  \>\kw{if} $nbdisabled = n$ \kw{then} \\
  \>\pindent\synchro{\myref{ReleaseAllChannels}($chans$)} \\
  \>\>\compiletime{Compile(\kw{end}, STATUS\_BLOCKED)} \\
  \>\kw{endif} \\
  \>\compiletime{\kw{cfor} $i$ : \kw{int} \kw{from} $0$ \kw{to} $n-1$} \\
  \>\pindent\kw{if} $pt.enabled[i]$ \kw{then} \\
  \>\>\pindent\compiletime{\kw{cif} $\alpha_i$ is $c!v$ \kw{then}} \\
  \>\>\>\pindent\kw{var} $eval$ : \kw{function}($pt$ : PiThread) : Value \{ \\
  \>\>\>\>\pindent\kw{begin} \\
  \>\>\>\>\>\pindent\compiletime{\myref{CompileExpr}($v$)} \\
  \>\>\>\>\>\>\kw{return} $pt.val$ \\
  \>\>\>\>\>\kw{end} \\
  \>\>\>\>\} \\
  \>\>\>\>\myref{RegisterOutputCommitment}($pt, pt.env[c], eval, choice\_cont[i]$) \\
  \>\>\>\compiletime{\kw{elseif} $\alpha_i$ is $c?x$ \kw{then}} \\
  \>\>\>\pindent\myref{RegisterInputCommitment}($pt, pt.env[c], x, choice\_cont[i]$) \\
  \>\>\>\compiletime{\kw{cendif}} \\
  \>\>\kw{endif} \\
  \>\compiletime{\kw{cendfor}} \\
  \>\synchro{Acquire($pt.lock$)} \\
  \>\synchro{\myref{ReleaseAllChannels}($chans$)} \\
  \>\compiletime{\myref{CompileWait()}} \\
  \>\compiletime{\kw{cfor} $i$ : \kw{int} \kw{from} $0$ \kw{to} $n-1$} \\
  \>\pindent \kw{case} $@choice\_cont[i]:$ \\
  \>\>\compiletime{Compile($P_i$)} \\
  \>\compiletime{\kw{cendfor}} \\
  \kw{end}
\end{program}

\algosection{Compilation outline for single choice (optimization)}
\begin{program}
  \compiletime{Compile($[g]\alpha.P$) $\rightarrow$} \\ \\
  \kw{begin} \\
  \pindent\kw{var} $tryresult$ : \{ENABLED, DISABLED, COMMIT\} \\
  \>\compiletime{\kw{cvar} $choice\_cont$ : \kw{dynLabel}} \\
  \>\compiletime{$choice\_cont \leftarrow$ GenerateLabel()} \\
  \>\compiletime{\kw{cvar} $choice\_stuck$ : \kw{dynLabel}} \\
  \>\compiletime{$choice\_stuck \leftarrow$ GenerateLabel()} \\
  \>\kw{var} $chans$ : Set[\myref{Channel}] \\
  \>$chans \leftarrow \{\}$ \\
  \>\compiletime{\myref{CompileExpr}($g_i$)} \\
  \>\kw{if} $pt.val$ \kw{then} \\
  \>\pindent\compiletime{\myref{CompileTryAction}($\alpha_i, chans$)} \\
  \>\>\kw{if} $tryresult =$ DISABLED \kw{then} \\
  \>\>\pindent\kw{goto} $@choice\_stuck$ \\
  \>\>\kw{else} \kw{if} $tryresult =$ ENABLED \kw{then} \\
  \>\>\pindent$pt.fuel \leftarrow pt.fuel - 1$ \\
  \>\>\>\kw{if} $pt.fuel = 0$ \kw{then} \\
  \>\>\>\pindent\synchro{\myref{ReleaseAllChannels}($chans$)} \\
  \>\>\>\>\compiletime{\myref{CompileYield}($choice\_cont$)} \\
  \>\>\>\kw{endif} \\
  \>\>\>\kw{goto} $@choice\_cont$ \\
  \>\>\kw{endif} \\
    \>\kw{else} \\
  \>\>\kw{goto} $@choice\_stuck$ \\
  \>\kw{endif} \\
  \>\compiletime{\kw{cif} $\alpha$ is $c!v$ \kw{then}} \\
  \>\>\kw{var} $eval$ : \kw{function}($pt$ : PiThread) : Value \{ \\
  \>\>\pindent\kw{begin} \\
  \>\>\>\pindent\compiletime{\myref{CompileExpr}($v$)} \\
  \>\>\>\>\kw{return} $pt.val$ \\
  \>\>\>\kw{end} \\
  \>\>\} \\
  \>\>\myref{RegisterOutputCommitment}($pt, pt.env[c], eval, choice\_cont$) \\
  \>\compiletime{\kw{celseif} $\alpha$ is $c?x$ \kw{then}} \\
  \>\>\myref{RegisterInputCommitment}($pt, pt.env[c], x, choice\_cont$) \\
  \>\compiletime{\kw{cendif}} \\
  \>\synchro{Acquire($pt.lock$)} \\
  \>\synchro{\myref{ReleaseAllChannels}($chans$)} \\
  \>\compiletime{\myref{CompileWait()}} \\
  \> \kw{case} $@choice\_stuck:$ \\
  \>\>\synchro{\myref{ReleaseAllChannels}($chans$)} \\
  \>\>\compiletime{Compile(\kw{end}, STATUS\_BLOCKED)} \\
  \>\kw{case} $@choice\_cont:$ \\
  \>\>\compiletime{Compile($P$)} \\
  \kw{end}
\end{program}

\label{CompileTryAction}
\algosection{Compilation outline for tau prefix try}
\begin{program}
  \compiletime{CompileTryAction(\kw{tau}, $chans$ : Set[\myref{Channel}]) $\rightarrow$} \\ \\
  $tryresult \leftarrow$ ENABLED \\
\end{program}

\newpage

\algosection{Compilation outline for output prefix try}
\begin{program}
  \compiletime{CompileTryAction($c!v$:T, $chans$ : Set[\myref{Channel}]) $\rightarrow$} \\ \\
  \kw{begin} \\
  \pindent\kw{var} $commit$ : \myref{InCommit} \\
  \> $commit \leftarrow$ TryOutputAction($pt$, $c$, $chans$, $\& tryResult$)\\
  \>\kw{if} $tryResult$ = ENABLED \kw{then} \\
  \>\pindent\compiletime{\myref{CompileExpr}($v$)} \\
  \>\>$commit.thread.env[commit.refval] \leftarrow pt.val$ \\
  \>\>\myref{Awake}($scheduler$, $commit.thread$, $commit$) \\
  \> \kw{endif}\\
  \kw{end}
\end{program}

\algosection{Runtime : try output action}
\begin{program}
  \kw{type} TryResult = \{ DISABLED, ENABLED, COMMIT \} \\
\\
  \kw{function} TryOutputAction($pt$ : \myref{PiThread}, $chanRef$ : int, $chans$: Set[\myref{Channel}], $tryResult$: \&TryResyult) : \myref{InCommit} \\
  \pindent \kw{if} SetAdd($chans, pt.env[chanRef]$) \kw{then} \\
  \>\pindent\synchro{Acquire($pt.env[chanRef].lock$)} \\
  \>\kw{endif} \\
  \>\kw{if} $pt.env[chanRef].globalrc = 1$ \kw{then} \\
  \>\pindent$tryResult \leftarrow$ DISABLED \\
  \>\>\kw{return} \kw{null} \\
  \>\kw{endif} \\
  \>\kw{var} $commit$ : \myref{InCommit} \\
  \>\kw{var} $ok$ : \{CANNOT\_ACQUIRE, VALID\_COMMITMENT, INVALID\_COMMITMENT\} \\
  \>\\
  \>\kw{do} \\
  \>\pindent$commit \leftarrow$ \myref{FetchInputCommitment}($pt.env[c]$) \\
  \>\>\kw{if} $commit =$ \kw{null} \kw{then} \\
  \>\>\pindent$tryresult \leftarrow$ COMMIT \\
  \>\>\>\kw{return} \kw{null} \\
  \>\>\kw{endif} \\

  \>\>\kw{do} \\
  \>\>\pindent$ok \leftarrow$ \myref{CanAwake}($commit.thread, commit$) \\
  \>\>\>\kw{if} $ok =$ CANNOT\_ACQUIRE \kw{then} \\
  \>\>\>\pindent\synchro{lowLevelYield()} \\
  \>\>\>\kw{endif} \\
  \>\>\kw{while} $ok =$ CANNOT\_ACQUIRE \\
  \>\>\\
  \>\>\kw{if} $ok =$ VALID\_COMMITMENT \kw{then} \\
  \>\>\> $tryResult \leftarrow$ ENABLED \\
  \>\>\> \kw{return} commit \\
  \>\>\kw{endif} \\
  \>\kw{while} $pt.env[c].incommits \neq \{\}$ \\
  errorDeadCodeReached() \\
  \kw{endfunction}
\end{program}

\newpage

\algosection{Compilation outline for input prefix try}
\begin{program}
  \compiletime{CompileTryAction($c?x$:T, $chans$:Set[\myref{Channel}]) $\rightarrow$} \\ \\
  \kw{begin} \\
  \pindent\kw{var} $commit$ : \myref{OutCommit} \\
  \> $commit \leftarrow$ TryInputAction($pt$, $c$, $chans$, $\& tryResult$) \\
  \>\kw{if} $tryResult =$ ENABLED \kw{then} \\
  \>\pindent $pt.env[x] \leftarrow$ commit.evalfunc($commit.thread$) \\
  \>\>\compiletime{\kw{cif} ischannel(T) \kw{then}} \\
  \>\>\pindent\kw{if} \myref{KnowsRegister}($pt.knows, pt.env[x]$) \kw{then} \\
  \>\>\>\pindent \myref{ChannelIncrRefCount}($pt.env[x]$) \\
  \>\>\>\kw{endif} \\
  \>\>\compiletime{\kw{cendif}} \\
  \>\>\myref{Awake}($scheduler, commit.thread, commit$) \\
  \>\kw{endif} \\
  \kw{end}
\end{program}

\algosection{Runtime : try input action}
\begin{program}
  \kw{type} TryResult = \{ DISABLED, ENABLED, COMMIT \} \\
\\
  \kw{function} TryInputAction($pt$ : \myref{PiThread}, $chanRef$ : int, $chans$: Set[\myref{Channel}], $tryResult$: \&TryResyult) : \myref{OutCommit} \\
  \pindent \kw{if} SetAdd($chans, pt.env[chanRef]$) \kw{then} \\
  \>\pindent\synchro{Acquire($pt.env[chanRef].lock$)} \\
  \>\kw{endif} \\
  \>\kw{if} $pt.env[chanRef].globalrc = 1$ \kw{then} \\
  \>\pindent$tryResult \leftarrow$ DISABLED \\
  \>\>\kw{return} \kw{null} \\
  \>\kw{endif} \\
  \>\kw{var} $commit$ : \myref{OutCommit} \\
  \>\kw{var} $ok$ : \{CANNOT\_ACQUIRE, VALID\_COMMITMENT, INVALID\_COMMITMENT\} \\
  \>\\
  \>\kw{do} \\
  \>\pindent$commit \leftarrow$ \myref{FetchOutputCommitment}($pt.env[chanRef]$) \\
  \>\>\kw{if} $commit =$ \kw{null} \kw{then} \\
  \>\>\pindent$tryresult \leftarrow$ COMMIT \\
  \>\>\>\kw{return} \kw{null} \\
  \>\>\kw{endif} \\

  \>\>\kw{do} \\
  \>\>\pindent$ok \leftarrow$ \myref{CanAwake}($commit.thread, commit$) \\
  \>\>\>\kw{if} $ok =$ CANNOT\_ACQUIRE \kw{then} \\
  \>\>\>\pindent\synchro{lowLevelYield()} \\
  \>\>\>\kw{endif} \\
  \>\>\kw{while} $ok =$ CANNOT\_ACQUIRE \\
  \>\>\\
  \>\>\kw{if} $ok =$ VALID\_COMMITMENT \kw{then} \\
  \>\>\> $tryResult \leftarrow$ ENABLED \\
  \>\>\> \kw{return} commit \\
  \>\>\kw{endif} \\
  \>\kw{while} $pt.env[chanRef].outcommits \neq \{\}$ \\
  errorDeadCodeReached() \\
  \kw{endfunction}
\end{program}

\newpage

\algosection{Runtime : atomic boolean acquisition}
\begin{program}
  \kw{function} Acquire($c$ : AtomicBoolean) \\
  \pindent\kw{while} CompareAndSwap($c$, \kw{false}, \kw{true}) $\neq$ \kw{false} \\
  \>\pindent// could not acquire \\
  \>\>\synchro{low\_level\_yield()} \\
  \>\kw{endwhile} \\
  \kw{endfunction}
\end{program}

\algosection{Runtime : atomic integer release}
\begin{program}
  \kw{function} Release($c$ : AtomicBoolean) \\
  \pindent\kw{if} CompareAndSwap($c$, \kw{true} \kw{false}) $\neq$ \kw{true} \kw{then} \\
  \>\pindent Crash(KERNEL\_ERROR) \\
  \>\kw{endif} \\
  \kw{endfunction}
\end{program}

\label{FetchInputCommitment}
\algosection{Runtime : input commitment search}
\begin{program}
  \kw{function} FetchInputCommitment($c$ : \myref{Channel}) \\
  \pindent\kw{var} $current$ : \myref{InCommit} \\
  \>$current \leftarrow$ \myref{CommitListFetch}($c.incommits$) \\
  \>\kw{while} $current \neq$ \kw{null} \kw{do} \\
  \>\pindent\kw{if} \myref{IsValidInCommit}($current$) \kw{then} \\
  \>\>\pindent\kw{return} $current$ \\
  \>\>\kw{endif} \\
  \>\>$current \leftarrow$ \myref{CommitListFetch}($c.incommits$) \\
  \>\kw{endwhile} \\
  \>\kw{return} \kw{null} \\
  \kw{endfunction}
\end{program}

\label{FetchOutputCommitment}
\algosection{Runtime : output commitment search}
\begin{program}
  \kw{function} FetchOutputCommitment($c$ : \myref{Channel}) \\
  \pindent\kw{var} $current$ : \myref{OutCommit} \\
  \>$current \leftarrow$ \myref{CommitListFetch}($c.outcommits$) \\
  \>\kw{while} $current \neq$ \kw{null} \kw{do} \\
  \>\pindent\kw{if} \myref{IsValidOutCommit}($current$) \kw{then} \\
  \>\>\pindent\kw{return} $current$ \\
  \>\>\kw{endif} \\
  \>\>$current \leftarrow$ \myref{CommitListFetch}($c.outcommits$) \\
  \>\kw{endwhile} \\
  \>\kw{return} \kw{null} \\
  \kw{endfunction}
\end{program}

\newpage

\label{RegisterInputCommitment}
\algosection{Runtime : input commitment register}
\begin{program}
  \kw{function} RegisterInputCommitment($pt$: \myref{PiThread}, $c$ : \myref{Channel}, $x$ : \kw{int}, $cont\_pc$ : \kw{int}) \\
  \pindent\kw{var} $newcommit$ : \myref{InCommit} \\
  \>$newcommit \leftarrow$ \kw{new} InCommit \\
  \>$newcommit.thread \leftarrow pt$ \\
  \>$newcommit.cont\_pc \leftarrow cont\_pc$ \\
  \>$newcommit.refvar \leftarrow x$\\
  \>$newcommit.clock \leftarrow pt.clock$ \\
  \>$newcommit.clockval \leftarrow pt.clock.val$ \\
  \>$newcommit.channel \leftarrow c$ \\
  \>\myref{CommitListAdd}($pt.env[c].incommits$, $newcommit$) \\
  \kw{endfunction}
\end{program}

\label{RegisterOutputCommitment}
\algosection{Runtime : output commitment register}
\begin{program}
  \kw{function} RegisterOutputCommitment($pt$: \myref{PiThread}, $c$ : \myref{Channel}, $v$ : \kw{function}(\myref{PiThread}), $cont\_pc$ : \kw{int}) \\
  \pindent\kw{var} $newcommit$ : \myref{OutCommit} \\
  \>$newcommit \leftarrow$ \kw{new} OutCommit \\
  \>$newcommit.thread \leftarrow pt$ \\
  \>$newcommit.cont\_pc \leftarrow cont\_pc$ \\
  \>$newcommit.evalfunc \leftarrow v$ \\
  \>$newcommit.clock \leftarrow pt.clock$ \\
  \>$newcommit.clockval \leftarrow pt.clock.val$ \\
  \>$newcommit.channel \leftarrow c$ \\
  \>\myref{CommitListAdd}($pt.env[c].outcommits$, $newcommit$) \\
  \kw{endfunction}
\end{program}

\label{IsValidInCommit}
\algosection{Runtime : input commitment validation}
\begin{program}
  \kw{function} IsValidInCommit($commit$ : \myref{InCommit}) \\
  \pindent\kw{if} $commit.clock = commit.thread.clock$ \kw{then} \\
  \>\pindent\kw{if} $commit.clockval = commit.thread.clock.val$ \kw{then} \\
  \>\>\pindent \kw{return} \kw{true} \\
  \>\>\kw{endif} \\
  \>\kw{endif} \\
  \>\kw{return} \kw{false} \\
  \kw{endfunction}
\end{program}

\label{IsValidOutCommit}
\algosection{Runtime : output commitment validation}
\begin{program}
  \kw{function} IsValidOutCommit($commit$ : \myref{OutCommit}) \\
  \pindent\kw{if} $commit.clock = commit.thread.clock$ \kw{then} \\
  \>\pindent\kw{if} $commit.clockval = commit.thread.clock.val$ \kw{then} \\
  \>\>\pindent \kw{return} \kw{true} \\
  \>\>\kw{endif} \\
  \>\kw{endif} \\
  \>\kw{return} \kw{false} \\
  \kw{endfunction}
\end{program}

\newpage

\label{CanAwake}
\algosection{Runtime : thread awake test}
\begin{program}
  \kw{function} CanAwake($thread$ : \myref{PiThread}, $commit$ : \myref{Commit}) \\
  \pindent\kw{if} \synchro{\kw{not} TryAcquire($thread.lock$)} \kw{then} \\
  \>\pindent\kw{return} CANNOT\_ACQUIRE \\
  \>\kw{endif} \\
  \>\kw{if} ($commit.clock \neq clock$) \kw{or} ($commit.clockval \neq commit.clock.val$) \kw{then} \\
  \>\pindent\synchro{Release($thread.lock$)} \\
  \>\>\kw{return} INVALID\_COMMITMENT \\
  \>\kw{endif} \\
  \>\kw{if} $thread.clock.val =$ MAX\_INT \kw{then} \\
  \>\pindent\kw{var} $oldclock \leftarrow thread.clock$ \\
  \>\>$thread.clock \leftarrow$ \kw{Null} \\
  \>\>ReclaimClock($oldclock$) \\
  \>\>$thread.clock \leftarrow$ \myref{GenerateClock()} \\
  \>\kw{else} \\
  \>\pindent$thread.clock.val \leftarrow thread.clock.val + 1$ \\
  \>\kw{endif} \\
  \>$thread.commit \leftarrow commit$ \\
  \>\synchro{Release($thread.lock$)} \\
  \>\kw{return} VALID\_COMMITMENT \\
  \kw{endfunction}
\end{program}

\label{Awake}
\algosection{Runtime : effective thread awake}
\begin{program}
  \kw{function} Awake($scheduler$ : \myref{Scheduler}, $thread$ : \myref{PiThread}) \\
  \pindent\kw{if} $thread.commit \neq commit$ \kw{then} \\
  \>\pindent Crash() \\
  \>\kw{endif} \\
  \>\synchro{\myref{WaitQueueFetch}($scheduler.wait, thread$)} \\
  \>$thread.commit \leftarrow$ \kw{null} \\
  \>$thread.pc \leftarrow commit.cont\_pc$ \\
  \>$thread.status \leftarrow$ STATUS\_RUN \\
  \>\synchro{\myref{ReadyQueuePush}($scheduler.ready, thread$)} \\
  \kw{endfunction}
\end{program}

\label{GenerateClock}
\algosection{Runtime : clock generation}
\begin{program}
  \kw{function} GenerateClock() \\
  \pindent\kw{var} $clock$ : \myref{Clock} \\
  \>$clock \leftarrow$ \kw{new} Clock \\
  \>$clock.val = 0$ \\
  \>\kw{return} $clock$ \\
  \kw{endfunction}
\end{program}

\label{ChannelIncrRefCount}
\algosection{Runtime : channel ref count incrementation}
\begin{program}
  \kw{function} ChannelIncrRefCount($chan$ : \myref{Channel}) \\
  \pindent\synchro{Acquire($chan.lock$)} \\
  \>$chan.globalrc \leftarrow chan.globalrc + 1$ \\
  \>\synchro{Release($chan.lock$)} \\
  \kw{endfunction}
\end{program}

\label{ChanneldDecRefCount}
\algosection{Runtime : channel ref count decrementation}
\begin{program}
  \kw{function} ChannelDecRefCount($chan$ : \myref{Channel}) \\
  \pindent\synchro{Acquire($chan.lock$)} \\
  \>$chan.globalrc \leftarrow chan.globalrc - 1$ \\
  \>\kw{if} $chan.globalrc = 0$ \kw{then} \\
  \>\pindent\synchro{Release($chan.lock$)} \\
  \>\> ReclaimChannel($chan$) \\
  \>\kw{else} \\
  \>\pindent\synchro{Release($chan.lock$)} \\
  \>\kw{endif} \\
  \kw{endfunction}
\end{program}

\algosection{Compilation outline for channel creation}
\begin{program}
  \compiletime{CompileTryAction(\kw{new}($c$), Set[\myref{Channel}]) $\rightarrow$} \\ \\
  \kw{begin} \\
  \pindent\kw{var} $channel$ : \myref{Channel} \\
  \>$channel \leftarrow$ \myref{GenerateChannel}() \\
  \>$pt.env[c] \leftarrow channel$ \\
  \>\myref{KnowsSetSwitch}($pt.knows, channel$, KNOWN) \\
  \>$tryresult \leftarrow$ ENABLED \\
  \kw{end}
\end{program}

\label{GenerateChannel}
\algosection{Runtime : channel generation}
\begin{program}
  \kw{function} GenerateChannel() \\
  \pindent\kw{var} $newchan$ : \myref{Channel} \\
  \>$newchan \leftarrow$ \kw{new} Channel \\
  \>$newchan.incommits \leftarrow$ \kw{new} CommitList[\myref{InCommit}] \\
  \>$newchan.outcommits \leftarrow$ \kw{new} CommitList[\myref{OutCommit}] \\
  \>$newchan.globalrc \leftarrow 1$ \\ 
  \> \kw{return} $newchan$ \\
  \kw{endfunction}
\end{program}

\newpage

\algosection{Compilation outline for thread creation}
\begin{program}
  \compiletime{CompileTryAction(\kw{spawn}\{D($v_1$:T$_1, ..., v_n$:T$_n$)\}, Set[\myref{Channel}]) $\rightarrow$} \\ \\
  \kw{begin} \\
  \pindent\kw{var} $args$ : Array[$n$ * Value] \\
  \>\kw{var} $child$ : \myref{PiThread} \\
  \>$child \leftarrow$ \myref{GeneratePiThread}() \\
  \>\\
  \>\compiletime{\kw{cfor} $i$ : \kw{int} \kw{from} $1$ \kw{to} $n$} \\
  \>\pindent\compiletime{\myref{CompileExpr}($v_i$)} \\
  \>\>$args[i-1] \leftarrow pt.val$ \\
  \>\>\compiletime{\kw{cif} ischannel(T$_i$) \kw{then}} \\
  \>\>\pindent \myref{KnowsRegister}($child.knows, args[i-1]$) \\
  \>\>\compiletime{\kw{cendif}} \\
  \>\>$child.env[i-1] \leftarrow args[i-1]$ \\
  \>\compiletime{\kw{cendfor}} \\
  \>\\
  \>$child.proc \leftarrow D$ \\
  \>$child.pc \leftarrow @D\_entry$ \\
  \>$child.status \leftarrow$ STATUS\_RUN \\
  \>\synchro{\myref{ReadyQueuePush}($scheduler.ready, child$)} \\
  \>$tryresult \leftarrow$ ENABLED \\
  \kw{end}
\end{program}

\label{GeneratePiThread}
\algosection{Runtime : thread generation}
\begin{program}
  \kw{function} GeneratePiThread() \\
  \pindent\kw{var} $newthread$ : \myref{PiThread} \\
  \> $newthread \leftarrow$ \kw{new} PiThread \\
  \> $newthread.knows \leftarrow$ \kw{new} KnowsSet[\myref{Channel}] \\
  \> $newthread.fuel \leftarrow$ FUEL\_INIT \\
  \> \kw{return} $newthread$ \\
  \kw{endfunction}
\end{program}

\newpage

\label{Main}
\algosection{Runtime : program entry point}
\begin{program}
  \kw{procedure} Main($nb\_core\_threads$ : \kw{int}, $entrypoint$ : \kw{function}) \\
  \pindent\kw{var} $schedpool$ : \myref{SchedPool} \\
  \>$schedpool \leftarrow$ \kw{new} SchedPool \\
  \>$schedpool.waiting\_slaves \leftarrow 0$ \\
  \>$schedpool.running \leftarrow$ \kw{true} \\
  \>\\
  \>\kw{for} $i$ : \kw{int} \kw{from} $0$ \kw{to} $nb\_core\_threads - 1$ \\
  \>\pindent ThreadCreate($\myref{SchedulerSlave}, schedpool$) \\
  \>\>$schedpool.nb\_slaves \leftarrow schedpool.nb\_slaves + 1$ \\
  \>\kw{endfor} \\
  \>\\
  \>\kw{while} $schedpool.wait\_slaves \neq schedpool\_nb\_slaves$ \\
  \>\pindent\synchro{low\_level\_yield()} \\
  \>\kw{endwhile} \\
  \>\\
  \>\kw{var} $initthread$ : \myref{PiThread} \\
  \>$initthread \leftarrow$ \myref{GenerateThread}() \\
  \>$initthread.proc \leftarrow entrypoint$ \\
  \>$initthread.pc \leftarrow @entrypoint\_entry$ \\
  \>\\
  \>\myref{ReadyQueuePush}($schedpool.ready, initthread$) \\
  \>\myref{SchedulerMaster}($schedpool$) \\
  \kw{endprocedure}
\end{program}

\label{SchedulerSlave}
\algosection{Runtime : slave scheduler}
\begin{program}
  \kw{procedure} SchedulerSlave($schedpool$ : \myref{SchedPool}) \\
  \pindent\kw{var} $current$ : \myref{PiThread} \\
  \>\kw{while} $schedpool.running$ \\
  \>\pindent\kw{while} ReadyQueueSize($schedpool.ready$) $\neq 0$ \\
  \>\>\pindent$current \leftarrow$ \synchro{\myref{ReadyQueuePop}($schedpool.ready$)} \\
  \>\>\>\kw{do} \\
  \>\>\>\pindent$current.proc$($schedpool, current$) \\
  \>\>\>\kw{while} $current.status =$ STATUS\_CALL \\
  \>\>\>\kw{if} $safe\_choice$ \kw{and} $current.status =$ STATUS\_BLOCKED \kw{then} \\
  \>\>\>\pindent Crash(DEADLOCK) \\
  \>\>\>\kw{endif} \\
  \>\>\kw{endwhile} \\
  \>\>\synchro{Acquire($schedpool.lock$)} \\
  \>\>$schedpool.nb\_waiting\_slaves \leftarrow schedpool.nb\_waiting\_slaves + 1$ \\
  \>\>\synchro{CondWait($schedpool.lock, schedpool.cond$)} \\
  \>\>$schedpool.nb\_waiting\_slaves \leftarrow schedpool.nb\_waiting\_slaves - 1$ \\
  \>\>\synchro{Release($schedpool.lock$)} \\
  \>\kw{endwhile} \\
  \kw{endprocedure}
\end{program}

\newpage

\label{SchedulerMaster}
\algosection{Runtime : master scheduler}
\begin{program}
  \kw{procedure} SchedulerMaster($schedpool$ : \myref{SchedPool}, $std\_gc\_fuel$ : \kw{int}, $quick\_gc\_fuel$ : \kw{int}, $active\_factor$ : \kw{int}) \\
  \pindent\kw{var} $current$ : \myref{PiThread} \\
  \>\kw{var} $gc\_fuel$ : \kw{int} \\
  \>$gc\_fuel \leftarrow std\_gc\_fuel$ \\
  \>\\
  \> /* \kw{pre} : schedpool.running = true */ \\
  \>\kw{while} $schedpool.running$ \\
  \>\pindent\kw{while} ReadyQueueSize($schedpool.ready$) $\neq 0$ \\
  \>\>\pindent$current \leftarrow$ \synchro{\myref{ReadyQueuePop}($schedpool.ready$)} \\
  \>\>\>\kw{if} \myref{ReadyQueueSize}($schedpool.ready$) $\ge 1$ \kw{and} $schedpool.nb\_waiting\_slaves < schedpool.nb\_slaves$ \kw{then} \\
  \>\>\>\pindent\synchro{Acquire($schedpool.lock$)} \\
  \>\>\>\>\synchro{CondSignal($schedpool.lock, schedpool.cond$)} \\
  \>\>\>\>\synchro{Release($schedpool.lock$)} \\
  \>\>\>\kw{endif} \\
  \>\>\>\kw{do} \\
  \>\>\>\pindent$current.proc(schedpool, current)$ \\
  \>\>\>\kw{while} $current.status =$ STATUS\_CALL \\
  \>\>\>\kw{if} $safe\_choice$ \kw{and} $current.status =$ STATUS\_BLOCKED \kw{then} \\
  \>\>\>\pindent Crash(DEADLOCK) \\
  \>\>\>\kw{endif} \\
  \>\>\>\\
  \>\>\>$gc\_fuel \leftarrow gc\_fuel - 1$ \\
  \>\>\>\kw{if} $gc\_fuel = 0$ \kw{then} \\
  \>\>\>\pindent\kw{var} $maxactive$ : \kw{int} \\
  \>\>\>\>$maxactive \leftarrow$ WaitQueueMaxActive($schedpool.wait$) \\
  \>\>\>\>\kw{if} WaitQueueSize($schedpool.wait$) $> maxactive * active\_factor$ \kw{then} \\
  \>\>\>\>\pindent WaitQueueMaxActiveReset($schedpool.wait$) \\
  \>\>\>\>\>\kw{var} $gc\_ok$ : \kw{boolean} \\
  \>\>\>\>\>$gc\_ok \leftarrow$ GC2($schedpool$) \\
  \>\>\>\>\>\kw{if} \kw{not} $gc\_ok$ \kw{or} WaitQueueSize($schedpool.wait$) $> maxactive * active\_factor$ \kw{then} \\
  \>\>\>\>\>\pindent$gc\_fuel \leftarrow quick\_gc\_fuel$ \\
  \>\>\>\>\>\kw{else} \\
  \>\>\>\>\>\pindent$gc\_fuel \leftarrow std\_gc\_fuel$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\kw{endif} \\
  \>\>\kw{endwhile} \\
  \>\> \\
  \>\>\synchro{Acquire($schedpool.lock$)} \\
  \>\>\kw{if} $schedpool.nb\_waiting\_slaves = schedpool.nb\_slaves$ \kw{then} \\
  \>\>\pindent $schedpool.running \leftarrow$ \kw{false} \\
  \>\>\synchro{CondBroadcast($schedpool.lock, schedpool.cond$)} \\
  \>\>\kw{endif} \\
  \>\>\synchro{Release($schedpool.lock$)} \\
  \>\kw{endwhile} \\
  \kw{endprocedure}
\end{program}

\newpage

\label{GC2}
\algosection{Runtime : second generation garbage collector}
\begin{program}
  \kw{function} GC2($sched$ : \myref{SchedPool}) \\
  \pindent\kw{var} $clique$ : Set[\myref{PiThread}] \\
  \>$clique \leftarrow \{\}$ \\
  \>\kw{var} $candidate$ : \myref{PiThread} \\
  \>$candidate \leftarrow$ \synchro{\myref{WaitQueuePopOld}($sched$)} \\
  \>\kw{if} \synchro{\kw{not} TryAcquire($candidate.lock$)} \kw{then} \\
  \>\pindent\synchro{\myref{WaitQueuePush}($candidate$)} \\
  \>\>\kw{return} \kw{false} \\
  \>\kw{endif} \\
  \>\kw{var} $candidates$ : Set[\myref{PiThread}] \\
  \>$candidates \leftarrow \{\}$ \\
  \>\kw{var} $chans$ : Set[\myref{Channel}] \\
  \>$chans \leftarrow \{\}$ \\
  \>SetAdd($candidates, candidate$) \\
  \> \\
  \>\kw{do} \\
  \>\pindent$candidate \leftarrow$ SetChoose($candidates$) \\
  \>\>\kw{for} $commit$ : \myref{Commit} \kw{in} $candidate.commits$ \\
  \>\>\pindent\kw{var} $chan$ : \myref{Channel} \\
  \>\>\>$chan \leftarrow commit.channel$ \\
  \>\>\>\kw{var} $refs$ : \kw{int} \\
  \>\>\>$refs \leftarrow 1$ \\
  \>\>\>\kw{if} SetAdd($chans, chan$) \kw{then} \\
  \>\>\>\pindent\kw{if} \synchro{\kw{not} TryAcquire($chan$)} \kw{then} \\
  \>\>\>\>\pindent\kw{goto} $@abandon\_gc$ \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\kw{else} \\
  \>\>\>\pindent\kw{continue} \\
  \>\>\>\kw{endif} \\
  \>\>\>\kw{for} $incommit$ : \myref{Commit} \kw{in} $chan.incommits$ \\
  \>\>\>\pindent\kw{if} \myref{IsValidInCommit}($incommit$) \kw{then} \\
  \>\>\>\>\>\kw{if} \synchro{\kw{not} TryAcquire($incommit.thread.lock$)} \kw{then} \\
  \>\>\>\>\>\pindent\synchro{\myref{WaitQueuePush}($sched.wait, incommit.thread$)} \\
  \>\>\>\>\>\>\kw{goto} $@abandon\_gc$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\pindent\kw{if} $incommit.thread.status \neq$ STATUS\_WAIT \kw{then} \\
  \>\>\>\>\>\pindent\kw{goto} $@abandon\_gc$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\>\synchro{\myref{WaitQueueFetch}($sched.wait, incommit.thread$)} \\
  \>\>\>\>\>\kw{if} SetAdd($candidates, incommit.thread$) \kw{then} \\
  \>\>\>\>\>\pindent$refs \leftarrow refs + 1$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\kw{else} \\
  \>\>\>\>\pindent RemoveInCommit() \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\kw{endfor} \\
  \>\>\>\kw{for} $outcommit$ : \myref{Commit} \kw{in} $chan.outcommits$ \\
  \>\>\>\pindent\kw{if} \myref{IsValidOutCommit}($outcommit$) \kw{then} \\
  \>\>\>\>\pindent\kw{if} $outcommit.thread.status \neq$ STATUS\_WAIT \kw{then} \\
  \>\>\>\>\>\pindent\kw{goto} $@abandon\_gc$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\>\synchro{\myref{WaitQueuePop}($sched.wait, outcommit.thread$)} \\
  \>\>\>\>\>\kw{if} \synchro{\kw{not} TryAcquire($outcommit.thread.lock$)} \kw{then} \\
  \>\>\>\>\>\pindent\synchro{\myref{WaitQueuePush}($sched.wait, outcommit.thread$)} \\
  \>\>\>\>\>\>\kw{goto} $@abandon\_gc$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\>\kw{if} SetAdd($candidates, outcommit.thread$) \kw{then} \\
  \>\>\>\>\>\pindent$refs \leftarrow refs + 1$ \\
  \>\>\>\>\>\kw{endif} \\
  \>\>\>\>\kw{else} \\
  \>\>\>\>\pindent RemoveOutCommit() \\
  \>\>\>\>\kw{endif} \\
  \>\>\>\kw{endfor} \\
  \>\>\> \\
  \>\>\>\kw{if} $refs < chan.globalrc$ \kw{then} \\
  \>\>\>\pindent\kw{goto} $@abandon\_gc$ \\
  \>\>\>\kw{endif} \\
  \>\>\kw{endfor} \\
  \>\>SetAdd($clique, candidate$) \\
  \>\kw{while} SetSize($candidates$) $> 0$ \\
  \> \\
  \>\kw{for} $deadthread$ : \myref{PiThread} \kw{in} $clique$ \\
  \>\pindent ReclaimPiThread($deadthread$) \\
  \>\kw{endif} \\
  \>\kw{return} \kw{true} \\
  \> \\
  \>$@abandon\_gc$ \\
  \>\kw{for} $thread$ : \myref{PiThread} \kw{in} $clique$ \\
  \>\pindent\synchro{\myref{WaitQueuePush}($sched.wait, thread$)} \\
  \>\>\synchro{Release($thread.lock$)} \\
  \>\kw{endfor} \\
  \>\kw{for} $thread$ : \myref{PiThread} \kw{in} $candidates$ \\
  \>\pindent\synchro{\myref{WaitQueuePush}($sched.wait, thread$)} \\
  \>\>\synchro{Release($thread.lock$)} \\
  \>\kw{endfor} \\
  \>\synchro{ReleaseAllChannels($chans$)} \\
  \>\kw{return} \kw{false} \\
  \kw{endfunction}
\end{program}

\end{document}
